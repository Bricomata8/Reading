Hindawi Publishing Corporation Mathematical Problems in Engineering Volume 2016, Article ID 8947157, 20 pages http://dx.doi.org/10.1155/2016/8947157
Research Article Verifying Service Choreography Model Based on Description Logic
Minggang Yu, Zhixue Wang, and Xiaoxing Niu
Institute of Command Information System, PLA University of Science and Technology, Nanjing 210007, China
Correspondence should be addressed to Zhixue Wang; wzxcx@163.com
Received 9 May 2015; Revised 23 June 2015; Accepted 14 July 2015 Academic Editor: Jean-FrancÂ¸ois Monin Copyright Â© 2016 Minggang Yu et al. This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.
Web Services Choreography Description Language lacks a formal system to accurately express the semantics of service behaviors and verify the correctness of a service choreography model. The paper presents a new approach of choreography model verification based on Description Logic. A metamodel of service choreography is built to provide a conceptual framework to capture the formal syntax and semantics of service choreography. Based on the framework, a set of rules and constraints are defined in Description Logic for choreography model verification. To automate model verification, the UML-based service choreography model will be transformed, by the given algorithms, into the DL-based ontology, and thus the model properties can be verified by reasoning through the ontology with the help of a popular DL reasoner. A case study is given to demonstrate applicability of the method. Furthermore, the work will be compared with other related researches.

1. Introduction
Web service technology has been popularly applied due to its power of interoperation, which allows various applications to run on heterogeneous platforms. Standards for web service composition cover two different levels of view: choreography and orchestration [1, 2]. The choreography view describes the interactions between services from a global perspective, while the orchestration view focuses on the interactions between one party and others. The web service choreography description language (WS-CDL) [3] is an XML-based language for the description of peer-to-peer collaborations of participants from a global viewpoint. However, WS-CDL is a declarative language and the specified concepts are weakly constrained. It lacks a formal system to accurately express the semantics of service behaviors and verify the correctness of a service choreography model. As a result, the built models may suffer from the problem of inconsistency, conflict, and realizability.
A number of approaches are suggested for formally modeling and verifying web services composition. Xiao et al. [4] proposed a process algebra called probabilistic priced process

algebra (PPPA) for modeling and analyzing web service composition from both functionality and nonfunctionality, such as reliability and performance. Moreover, they provided a united method based on PPPA to model and analyze both functionality and QoS of web service composition. Cambronero et al. [5] presented an approach to validation and verification of web services choreographies and more specifically for composite web services systems with timing restrictions. They defined operational semantics for a relevant subset of WS-CDL and then provided a translation of the considered subset into a network of timed automata for the validation and verification using the UPPAAL tool. Zhou et al. [6] put forward an approach to testing WS-CDL programs automatically. The dynamic symbolic execution technique was used to generate test inputs, and assertions are treated as the test oracles. An engine that can simulate WS-CDL is used to execute the WS-CDL programs during symbolic execution. Besson et al. [7] adapted the automated testing techniques used by the Agile Software Development community to the SOA context to enable test-driven development of choreographies. They present the first step in that direction, a software

2

Mathematical Problems in Engineering

prototype composed of ad hoc automated test case scripts for testing a web service choreography. Gu et al. [8, 9] originally advocated for a formal modeling framework, called Abstract WS-CDL. This includes grammar, congruence relations, and operational semantics. They defined a set of mappings of the Abstract WS-CDL global model to the Pi calculus-based local model and subsequently suggested a set of deductive reasoning rules of state reachability and terminability.
One of the crucial questions in choreography-based development is to check the realizability and conformance properties. HalleÂ´ and Bultan [10] proposed a novel algorithm for deciding realizability by computing a finite state model that keeps track of the information about the global state of a conversation protocol that each peer can deduce from the messages it sends and receives. McNeile [11] provided a new technique that uses compositions of partial descriptions to define a choreography, and he demonstrated that realizability of a choreography defined as a composition only needs to be established individually for the components of the composition. Basu et al. [12] gave necessary and sufficient conditions for realizability of choreographies and implemented the proposed realizability check on three granularities: (1) web service choreographies, (2) singularity OS channel contracts, and (3) UML collaboration (communication) diagrams. Yeung [13] put forward a formal approach to web service composition and conformance verification based on WS-CDL and WS-BPEL. The main contributions included a precise notion of choreography conformance upon which verification is based and support for the complementary use of visual modeling (e.g., UML) and standard WS-âˆ— notations in composition.
We argue that checking the realizability and conformance properties should be approached in two ways. One is to check the completeness and consistency of a choreography specification to guarantee there are no logical conflicts in the specification. The other is to check whether the specified choreography behaves in a correct way or whether the system functions well to complete its jobs. Having investigated the recent research results, we found that most of them addressed only one side rather than both.
To solve the problem above, we propose an approach of choreography model verification based on Description Logic, or CMV-DL. A service choreography modeling framework is provided to support UML-based modeling. The metamodel of service choreography extends the WS-CDL specification. Two algorithms are given to transform the UML-based service choreography model into the DL-based ontology through which the verification can be made using a DL reasoner.
To enable automatic verification, we introduce Description Logic (DL) [14] to formalize the choreography model and define a set of rules and constraints for verification. DL is a knowledge representation language and is a decidable subset of first-order predicate logic. It contains a set of basic concept constructors, such as concept consumption (âŠ‘) and universal constraint (âˆ€). As a subset of DL, SHOIN(D) [15] is the logical basis of web ontology language (OWL) [16]. It is powerful in knowledge description ability, reasoning decidability, and knowledge reusability and more importantly

there are available supporting reasoners such Pellet [17] and Racer.
The rest of the paper is organized as follows. Section 2 introduces the service choreography modeling framework, highlighting the metamodel of service choreography. Section 3 discusses CMV-DL further on model verification mechanism and UML-DL conversion and introduces the deductive reasoning rules specified in Semantic Web Rule Language (SWRL) [18]. Section 4 provides a case study to show the potential usage of CMV-DL. Section 5 investigates the related work and draws a comparison between CMV-DL and other choreography verification methods. The final section brings a conclusion and foresees our future work.
2. Service Choreography Modeling Framework
According to the OMGâ€™s four-layered metamodel architecture, UML can be extended by defining new stereotypes at metamodel level (M2) [19] and thus becomes a domainspecific language. The modeling framework for service choreography is accordingly defined in two levels, as shown in Figure 1. The metamodel of service choreography is built by extending the concepts of WS-CDL to provide the syntax and semantics for visually presenting a choreography and define a set of domain rules for model checking. The application model specifies the concepts of service choreography of an application (or a system) by instantiating the concepts of the metamodel.
2.1. Metamodel of Service Choreography. To build the metamodel of service choreography, we define the main concepts of service choreography by referring to the WS-CDL specification.
Definition 1 (session (í µí±†)). A session is composed of a set of basic interactive activities which are performed by one or more participants in order to complete a specific function. Sessions can be denoted as a four-tuple structure: í µí±† = âŸ¨í µí±, í µí°´í µí±í µí±¡, í µí±…í µí±œ, í µí±ƒí µí±ŸâŸ©, where í µí± is the name, í µí°´í µí±í µí±¡ refers to the activities that realize this specific function, í µí±…í µí±œ is a set of the roles that participate in the activities, and í µí±ƒí µí±Ÿ is a set of the preconditions for carrying out this session.
Definition 2 (choreography (í µí°¶â„í µí±œ)). A choreography defines the collaboration contracts between the participants and the interoperations of cross-system behaviors. It can be denoted as a three-tuple structure: í µí°¶â„í µí±œ = âŸ¨í µí±, í µí±…í µí±œ, í µí±†âŸ©, where í µí± is the name, í µí±…í µí±œ is a set of the roles that participate in the interoperations, and í µí±† represents a set of sessions to be executed in the interoperation processes.
Definition 3 (metamodel). The metamodel of service choreography defines the syntax and semantics for visually presenting a choreography and provides a set of domain rules for checking the correctness properties of a choreography model. It is composed of three parts: âŸ¨MetaConcept, MetaRelation, DomainRuleâŸ©, where MetaConcept and MetaRelation are sets of metaconcepts and metarelations which are defined by inheriting the counterpart concepts from the WS-CDL

Mathematical Problems in Engineering

3

Service choreography model

Metamodel of service choreography

â€œClassâ€ MetaConcept

â€œRelationshipâ€ MetaRelation

â€œRuleâ€ DomainRule

Instance of

Instance of Constraint

â€œFunctionâ€ AppFunction

â€œIndividualâ€ AppConcept

â€œRelationshipâ€ AppRelation

Application model of service choreography

Mapping Mapping

The four-level hierarchy of OMG
M3 (MOF) Meta-metamodel
Instance of M2
Metamodel
Instance of
M1 model
Instance of M0 data

Figure 1: Service choreography modeling framework.

Class --Service choreography metaconcept model based on WS-CDL

Choreography

BasicActivity

StructuralActivity

0..âˆ—C1o.n.âˆ—tain+succeeding+p0.r.eâˆ—positive 0..âˆ—

Precondition Execute

Session

1..âˆ— Participate_by

1..âˆ—

Activity 1..âˆ—

Depend 1..âˆ—

Channel

1..âˆ— AtomicSession
Service 1..âˆ—
Construct Participant

1..âˆ—

CompoundSession 1..âˆ—

1..âˆ— Operation

Provide 1..âˆ—

Belong_to Implement

Perform

1..âˆ—

2

Role
1..âˆ— 1 Bind 1
Interface

Link
Has Variable 1..âˆ— Own 1..âˆ— 1..âˆ— Port

Figure 2: Metamodel of service choreography based on WS-CDL.

specification. The core elements of the metamodel are shown in Figure 2.
2.1.1. MetaConcept. MetaConcept is a finite set of metaconcepts that originate from WS-CDL but are not limited to it. New concepts, such as Session, AtomicSession, and CompoundSession, are extended for the purpose of formal modeling and verification. Table 1 provides detailed definitions and descriptions of the metaconcepts.

The concept activity can be divided into two kinds: BasicActivity (í µí°´í µí±í µí±í µí± ) and StructuralActivity (í µí°´í µí± í µí±¡í µí±Ÿ):

Act & Abas | Astr

(1)

í µí°´í µí±í µí±í µí±  is defined as

Abas & NoAction | SilentAction | Interaction | Assign | (2)
Perform

4

Mathematical Problems in Engineering

í µí°´í µí± í µí±¡í µí±Ÿ is used to describe a compound activity in following syntax and semantics:

í µí°´í µí± í µí±¡í µí±Ÿ & [í µí±] í µí°´í µí±í µí±¡

(condition)

| [í µí±] âˆ— í µí°´í µí±í µí±¡

(repeat)

| [í µí±í µí±”] [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí°´í µí±í µí±¡ (workunit)

| í µí°´í µí±í µí±¡1 â‹… í µí°´í µí±í µí±¡2

(sequence)

(3)

| í µí°´í µí±í µí±¡1 â€– í µí°´í µí±í µí±¡2

(parallel)

| í µí°´í µí±í µí±¡1Î¤í µí°´í µí±í µí±¡2

(non-deterministic)

| [í µí±1] í µí°´í µí±í µí±¡1 + [í µí±2] í µí°´í µí±í µí±¡2 (choice)

The structure of a compound activity appears either in workunit pattern or in control-flow pattern. The workunit structure is defined in WS-CDL by three substructures. The condition structure is expressed as [í µí±]í µí°´í µí±í µí±¡. The repeat

structure is expressed as [í µí±] âˆ— í µí°´í µí±í µí±¡. A workunit structure is
expressed as [í µí±í µí±”][í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí°´í µí±í µí±¡, which means that the activity will be blocked until the precondition í µí±í µí±” is evaluated to be â€œtrueâ€; that is, the activity is triggered by the precondition. If
í µí°´í µí±í µí±¡ terminates successfully and the repetition condition í µí±í µí±Ÿí µí±’í µí± is â€œtrue,â€ the workunit will repeat; otherwise, it will finish.
A control-flow structure is defined as any combination of
sequentially executed activities í µí°´í µí±í µí±¡1 â‹… í µí°´í µí±í µí±¡2, parallel executed activities í µí°´í µí±í µí±¡1 â€– í µí°´í µí±í µí±¡2, nondeterministically executed activities í µí°´í µí±í µí±¡1Î¤í µí°´í µí±í µí±¡2, or selectively executed activities [í µí±1]í µí°´í µí±í µí±¡1 + [í µí±2]í µí°´í µí±í µí±¡2.
The concept session can also be divided into two kinds:
AtomicSession (í µí±†í µí±í µí±¡í µí±œí µí±š) and CompoundSession (í µí±†í µí±í µí±œí µí±š):

í µí±† & í µí±†í µí±í µí±¡í µí±œí µí±š | í µí±†í µí±í µí±œí µí±š

(4)

An atomic session may appear in any form of the following:

í µí±†í µí±í µí±¡í µí±œí µí±š & í µí±…í µí±œ (Ã˜)

(í µí±†í µí±›í µí±œ)

| í µí±…í µí±œ (í µí¼)

(í µí±†silent)

| assign (í µí±…í µí±œ â‹… í µí±¥ = í µí±’)

(í µí±†assign)

| request (í µí±…í µí±œ1 â‹… í µí±¥ í®í¸€â†’ í µí±…í µí±œ2 â‹… í µí±¦, í µí°¶â„@í µí±…í µí±œ2)

(í µí±†req)

(5)

| respond (í µí±…í µí±œ1 â‹… í µí±¥ â†í®í¸€ í µí±…í µí±œ2 â‹… í µí±¦, í µí°¶â„@í µí±…í µí±œ1)

(í µí±†resp)

| req-resp (í µí±…í µí±œ1 â‹… í µí±¥ í®í¸€â†’ í µí±…í µí±œ2 â‹… í µí±¦, í µí±…í µí±œ1 â‹… V â†í®í¸€ í µí±…í µí±œ2 â‹… í µí±¢, í µí°¶â„@í µí±…í µí±œ2) (í µí±†req-resp)

| í µí°¶â„í µí±œ (í µí±¥1, í µí±¥2, í µí±¥3, . . .)

(í µí±†perform)

| í µí¼“

(NULL)

í µí±†í µí±›í µí±œ describes that the role í µí±…í µí±œ does not perform any operation; í µí±†í µí± í µí±–í µí±™í µí±’í µí±›í µí±¡ means that í µí±…í µí±œ performs an internal silent action í µí¼; í µí±†í µí±í µí± í µí± í µí±–í µí±”í µí±› describes an assignment operation that the value í µí±’ is assigned to the variable í µí±…í µí±œ â‹… í µí±¥; í µí±†í µí±Ÿí µí±’í µí± describes a request interaction from í µí±…í µí±œ1 to í µí±…í µí±œ2 through í µí°¶â„@í µí±…í µí±œ2, where the request message is sent from í µí±…í µí±œ1 â‹… í µí±¥ to í µí±…í µí±œ2 â‹… í µí±¦; í µí±†í µí±Ÿí µí±’í µí± í µí± describes a response interaction; í µí±†í µí±Ÿí µí±’í µí±-í µí±Ÿí µí±’í µí± í µí± describes requestresponse interaction; í µí±†í µí±í µí±’í µí±Ÿí µí±“í µí±œí µí±Ÿí µí±š describes invoking operation between sessions; and NULL denotes the termination state of
a session.
Two or more atomic sessions may be combined with one
another by structural connectors to become a compound session í µí±†í µí±í µí±œí µí±š. The combination follows the following syntax and semantics:

í µí±†í µí±í µí±œí µí±š & í µí±†1 â€– í µí±†2

(í µí±†í µí±í µí±í µí±Ÿí µí±í µí±™í µí±™í µí±’í µí±™)

| í µí±†1 â‹… í µí±†2

(í µí±†í µí± í µí±’í µí±í µí±¢í µí±’í µí±›í µí±í µí±’)

| [í µí±1] í µí±†1 + [í µí±2] í µí±†2 (í µí±†í µí±â„í µí±œí µí±–í µí±í µí±’)

(6)

| [í µí±í µí±”] [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† (í µí±†í µí±¤í µí±œí µí±Ÿí µí±˜í µí±¢í µí±›í µí±–í µí±¡)

í µí±†í µí±í µí±í µí±Ÿí µí±í µí±™í µí±™í µí±’í µí±™ describes two parallel executed sessions; í µí±†í µí± í µí±’í µí±í µí±¢í µí±’í µí±›í µí±í µí±’ describes two sequentially executed sessions where í µí±†1 is the predecessor and í µí±†2 is the successor; í µí±†í µí±â„í µí±œí µí±–í µí±í µí±’ describes two

selectively executed sessions that either í µí±†1 or í µí±†2 will be executed depending on whether the precondition í µí±1 or í µí±2 is met; í µí±†í µí±¤í µí±œí µí±Ÿí µí±˜í µí±¢í µí±›í µí±–í µí±¡ describes a repeatedly executed session, where í µí±† is triggered by the precondition í µí±í µí±” and it will be repeatedly
executed until í µí±í µí±Ÿí µí±’í µí± becomes â€œfalse.â€

2.1.2. MetaRelation. MetaRelation is a finite set of semantic
associations between the metaconcepts appearing in Table 1. It inherits the concepts of semantic verbs, such as Support, Perform, and Depend, from WS-CDL and is supplemented by some new relations such as SessionDeduction, Congruence, and Sequence, to enable comprehensive model checking.
Table 2 provides a set of core metarelations accompanied with their formal semantics specified in DL. The universal constraint âˆ€ is a DL symbol interpreted by (âˆ€í µí±… â‹… í µí°¶)í µí°¼ = {í µí± âˆˆ Î”í µí°¼ | âˆ€í µí±((í µí±, í µí±) âˆˆ í µí±…í µí°¼ â†’ í µí± âˆˆ í µí°¶í µí°¼)}, where í µí°¶ is a set of metaconcepts, í µí±… is a set of metarelations, and Î”í µí°¼ denotes nonempty set of discourse domains.

Definition 4 (SessionDeduction). SessionDeduction is defined

by a labeled

transition system: í µí±†

í µí±,í µí±
í®í®í¸€â†’í¸€

í µí±†í® í° , meaning

that the

session í µí±† will become í µí±†í® í°  in the future when the precondition í µí±

Mathematical Problems in Engineering

5

Table 1: A summary of metaconcepts of service choreography for the metamodel (a fragment).

Concepts Participant

Definition í µí±ƒí µí±í µí±Ÿ = âŸ¨í µí±, í µí±…í µí±œâŸ©

Role

í µí±…í µí±œ = âŸ¨í µí±, í µí±‚í µí±, í µí°¶â„, í µí±‰í µí±âŸ©

Activity

í µí°´í µí±í µí±¡ = âŸ¨í µí±, í µí°¶í µí±âŸ©

Precondition Guard Variable Operation

í µí±ƒ = âŸ¨í µí±, BooleanâŸ© í µí°º = âŸ¨í µí±ƒ, í µí±†âŸ©
í µí±‰í µí± = âŸ¨í µí±, í µí±…í µí±œâŸ© í µí±‚í µí± = âŸ¨í µí±, í µí±…í µí±œâŸ©

Channel

í µí°¶â„ = âŸ¨í µí±, í µí±…í µí±œ, í µí°¿í µí±œí µí±, í µí°¼í µí±›í µí±¡âŸ©

Interface Port

í µí°¼í µí±› = âŸ¨í µí±, í µí±ƒí µí±í µí±ŸâŸ© í µí±ƒí µí±œ = âŸ¨í µí±, í µí°¼í µí±›âŸ©

Description The business entities or web services that participate in service interaction. í µí± is the name and í µí±…í µí±œ denotes the roles it implements. The observable behavior a participant exhibits in order to collaborate. í µí±…í µí±œ initiates the collaborative operations (í µí±‚í µí±) through channels (í µí°¶â„) with other roles, and the local variables (í µí±‰í µí±) will be affected. The actual functions performed in the choreography. They (í µí°¶í µí±) can be categorized into basic activities and structural activities.
The preconditions of session execution, specified in Boolean type.
The bindings of preconditions to sessions.
The variables a role has. It is a component of a role specification.
The operations a role provides. It is a component of a role specification. The locations and manners through which information is exchanged between roles. í µí°¿í µí±œí µí± and í µí°¼í µí±›í µí±¡ denote the channel locations and interaction activities, respectively.
The declaration of the participants (í µí±ƒí µí±í µí±Ÿ) that collaborate.
The way through which roles interact. One interface may correspond to one role and multiports.

Table 2: A summary of metarelations of service choreography for the metamodel (a fragment).

Relations SessionDeduction Congruence Implement Contain Link Belong to HasName Provide Executing Sequence Parallel Choice WorkUnit

Correlative concepts Session Ã— Session Session Ã— Session Participant Ã— Role
Choreography Ã— Session Channel Ã— Role
Role Ã— Participant Role Ã— Name
Role Ã— operation Session Ã— í µí±†í µí±í µí±¡í µí±œí µí±š Session Ã— Session Session Ã— Session Session Ã— Session Session Ã— Session

Formal semantics Session âŠ‘ âˆ€ SessionDeduction. Session
Session âŠ‘ âˆ€ Congruence. Session Participant âŠ‘ âˆ€ Implement.Role Choreography âŠ‘ âˆ€ Contain.Session
Channel âŠ‘ âˆ€ Link.Role Role âŠ‘ âˆ€ Belong to.Participant
Role âŠ‘ âˆ€ HasName.Name Role âŠ‘ âˆ€ Provide.operation Session âŠ‘ âˆ€ Executing. í µí±†í µí±í µí±¡í µí±œí µí±š Session âŠ‘ âˆ€ Sequence. Session Session âŠ‘ âˆ€ Parallel. Session Session âŠ‘ âˆ€ Choice. Session Session âŠ‘ âˆ€ WorkUnit. Session

becomes true and the atomic session í µí± of í µí±† has been executed. SessionDeduction is defined for state reachability reasoning.
Definition 5 (congruence). If the two sessions í µí±† and í µí±†í® í°  behave exactly in same way, there is a congruence relation between them, marked with the symbol â‰¡. The conditions of congruence are listed as follows:

í µí°¶1 : [í µí±1] í µí±†1 + [í µí±2] í µí±†2 â‰¡ [í µí±2] í µí±†2 + [í µí±1] í µí±†1

í µí°¶2 : ([í µí±1] í µí±†1 + [í µí±2] í µí±†2) + [í µí±3] í µí±†3 â‰¡ [í µí±2] í µí±†2

+ ([í µí±1] í µí±†1 + [í µí±3] í µí±†3)

í µí°¶3 : [í µí±1] í µí±†1 + [í µí±2] í µí±†2 â‰¡ [í µí±1 âˆ¨ í µí±2] í µí±†

(7)

í µí°¶4 : í µí±†1 í®”í®”í®”í®”í´©í´©í´©í´©í µí±†2 â‰¡ í µí±†2 í®”í®”í®”í®”í´©í´©í´©í´©í µí±†1 (í µí±†1 â€– í µí±†2) í®”í®”í®”í®”í´©í´©í´©í´©í µí±†3 â‰¡ í µí±†1 í®”í®”í®”í®”í´©í´©í´©í´©(í µí±†2 í®”í®”í®”í®”í´©í´©í´©í´©í µí±†3 )

í µí°¶5 : í µí±† í®”í®”í®”í®”í´©í´©í´©í´©í µí±†í µí±›í µí±œ â‰¡ í µí±† í µí±† í®”í®”í®”í®”í´©í´©í´©í´©í µí±†í µí± í µí±–í µí±™í µí±’í µí±›í µí±¡ â‰¡ í µí±† í µí±† â€–í µí±í µí±ˆí µí°¿í µí°¿ â‰¡ í µí±†

í µí°¶6 : í µí±†í µí±›í µí±œ. í µí±† â‰¡ í µí±† í µí±†í µí± í µí±–í µí±™í µí±’í µí±›í µí±¡. í µí±† â‰¡ í µí±† í µí±í µí±ˆí µí°¿í µí°¿. í µí±† â‰¡ í µí±†

Definitions of MetaConcept and MetaRelation provide the syntax and semantics for modeling service choreography. In the subsequent sections, we will discuss the operational semantics for session evolution and the deductive domain rules for checking the properties of consistency, completeness, and state reachability of a service choreography model.
2.1.3. DomainRule. Domain rules are description of constraints for specific domains [20]. DomainRule is a set of rules defined upon the metamodel, providing overall constraints that need to be held by all concepts and relations in the service choreography model.
Domain rules of service choreography can be classified into three categories: consistency, completeness, and deductive reasoning. They are not limited to what we give in the following. They may be continuously enriched and improved as applied.
Definition 6 (consistency). A service choreography model is consistent provided that (1) the application model is built

6

Mathematical Problems in Engineering

consistent with the metamodel and (2) there is not any conflict among the concepts of the application model. A typical set of consistency rules are defined below.
(i) í µí±…í µí±í µí±œí µí±›1: if there is a metarelation í µí±… that associates the metaconcept í µí°¶í µí±– with í µí°¶í µí±— (í µí°¶í µí±– âŠ‘ âˆ€í µí±… â‹… í µí°¶í µí±—) in the metamodel and í µí±Ÿ is instance of í µí±… that associates the application concept í µí±í µí±– with í µí±í µí±— in the application model, then í µí±í µí±– must be an instance of í µí°¶í µí±– and í µí±í µí±— must be an instance of í µí°¶í µí±—.
(ii) í µí±…í µí±í µí±œí µí±›2: no more than one relation of Sequence, Parallel, Choice, or WorkUnit is allowed to associate a pair of sessions.
(iii) í µí±…í µí±í µí±œí µí±›3: if two sessions are associated with the relations í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±›í µí°·í µí±’í µí±‘í µí±¢í µí±í µí±¡í µí±–í µí±œí µí±›(í µí±†í µí±–, í µí±†í µí±—) and í µí°¶í µí±œí µí±›í µí±”í µí±Ÿí µí±¢í µí±’í µí±›í µí±í µí±’(í µí±†í µí±–, í µí±†í µí±—) (í µí±– =Ì¸ í µí±—) at the same time, the atomic session í µí±†í µí±í µí±¡í µí±œí µí±š associated with í µí±†í µí±– by the Executing relation must be in type of í µí±†í µí±›í µí±œ, í µí±†í µí± í µí±–í µí±™í µí±’í µí±›í µí±¡, or í µí±í µí±ˆí µí°¿í µí°¿.
(iv) í µí±…í µí±í µí±œí µí±›4: if two sessions are associated with the relation í µí°¸í µí±¥í µí±’í µí±í µí±¢í µí±¡í µí±–í µí±›í µí±”(í µí±†í µí±–, í µí±†í µí±—) (í µí±– =Ì¸ í µí±—), í µí±†í µí±— must be an atomic session, that is, í µí±†í µí±— : í µí±†í µí±í µí±¡í µí±œí µí±š.
(v) í µí±…í µí±í µí±œí µí±›5: if two associated application concepts í µí± and í µí± are declared in the application model, there must be a metaconcept í µí°¶ and a metarelation í µí±… that satisfy í µí± : í µí°¶ and (í µí±, í µí±) : í µí±….
(vi) í µí±…í µí±í µí±œí µí±›6: the two relations í µí±†í µí±’í µí±í µí±¢í µí±’í µí±›í µí±í µí±’(í µí±†í µí±–, í µí±†í µí±—) and í µí±†í µí±’í µí±í µí±¢í µí±’í µí±›í µí±í µí±’(í µí±†í µí±—, í µí±†í µí±–), í µí±– =Ì¸ í µí±—, are allowed to exist at the same time.
The WS-CDL specification includes many clauses stated with the keywords such as MUST/MUSTNOT, SHOULD/SHOULDNOT, and SHALL/SHALLNOT. Those clauses may relate to the consistency and completeness constraints. For example, â€œa Choreography MUST contain one or more sessions,â€ from which we can formally define a rule í µí°¶â„í µí±œí µí±Ÿí µí±’í µí±œí µí±”í µí±Ÿí µí±í µí±â„í µí±¦ âŠ‘â‰¥ 1 í µí°¶í µí±œí µí±›í µí±¡í µí±í µí±–í µí±›.í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› in DL. The DL expression â‰¥ í µí±›í µí±… â‹… í µí°¶, used for constraining a relation, is interpreted by (â‰¥í µí±›í µí±… â‹… í µí°¶)í µí°¼ = {í µí± âˆˆ Î”í µí°¼ | #{í µí± âˆˆ Î”í µí°¼ | (í µí±, í µí±) âˆˆ í µí±…í µí°¼ âˆ§ í µí± âˆˆ í µí°¶í µí°¼} â‰¥ í µí±›}, where í µí±… is a metarelation and í µí°¶ is a metaconcept, and Î”í µí°¼ denotes nonempty set of discourse domains.
Definition 7 (completeness). A service choreography model is complete provided that the number of the relations in the application model satisfies the multiplicity constraint of the corresponding metarelation in the metamodel. A typical set of completeness rules are defined below, according to the WSCDL specification:
(i) í µí±…í µí±í µí±œí µí±š1: í µí±…í µí±œí µí±™í µí±’ âŠ‘â‰¥ 1 í µí°µí µí±’í µí±™í µí±œí µí±›í µí±” í µí±¡í µí±œ.í µí±ƒí µí±í µí±Ÿí µí±¡í µí±–í µí±í µí±–í µí±í µí±í µí±›í µí±¡ âŠ“
í µí±…í µí±œí µí±™í µí±’ âŠ‘â‰¤ 1 í µí°µí µí±’í µí±™í µí±œí µí±›í µí±” í µí±¡í µí±œ.í µí±ƒí µí±í µí±Ÿí µí±¡í µí±–í µí±í µí±–í µí±í µí±í µí±›í µí±¡.
(ii) í µí±…í µí±í µí±œí µí±š2: í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› âŠ‘â‰¥ 1 í µí±†í µí±¢í µí±í µí±í µí±œí µí±Ÿí µí±¡.í µí°´í µí±í µí±¡í µí±–Ví µí±–í µí±¡í µí±¦. (iii) í µí±…í µí±í µí±œí µí±š3: í µí°¶â„í µí±í µí±›í µí±›í µí±’í µí±™ âŠ‘â‰¥ 2 í µí°¿í µí±–í µí±›í µí±˜.í µí±…í µí±œí µí±™í µí±’ âŠ“
í µí°¶â„í µí±í µí±›í µí±›í µí±’í µí±™ âŠ‘â‰¤ 2 í µí°¿í µí±–í µí±›í µí±˜.í µí±…í µí±œí µí±™í µí±’.

(iv) í µí±…í µí±í µí±œí µí±š4: í µí°¼í µí±›í µí±¡í µí±’í µí±Ÿí µí±í µí±í µí±¡í µí±–í µí±œí µí±› âŠ‘â‰¥ 1 í µí°·í µí±’í µí±í µí±í µí±›í µí±‘.í µí°¶â„í µí±í µí±›í µí±›í µí±’í µí±™. (v) í µí±…í µí±í µí±œí µí±š5: í µí±ƒí µí±í µí±Ÿí µí±¡í µí±–í µí±í µí±–í µí±í µí±í µí±›í µí±¡ âŠ‘â‰¥ 1 Implement.í µí±…í µí±œí µí±™í µí±’. (vi) í µí±…í µí±í µí±œí µí±š6: í µí°¶â„í µí±œí µí±Ÿí µí±’í µí±œí µí±”í µí±Ÿí µí±í µí±â„í µí±¦ âŠ‘â‰¥ 1 í µí°¶í µí±œí µí±›í µí±¡í µí±í µí±–í µí±›.í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±›. (vii) í µí±…í µí±í µí±œí µí±š7: í µí°¼í µí±›í µí±¡í µí±’í µí±Ÿí µí±“í µí±í µí±í µí±’ âŠ‘â‰¥ 1 í µí°µí µí±–í µí±›í µí±‘.í µí±…í µí±œí µí±™í µí±’ âŠ“
í µí°¼í µí±›í µí±¡í µí±’í µí±Ÿí µí±“í µí±í µí±í µí±’ âŠ‘â‰¤ 1 í µí°µí µí±–í µí±›í µí±‘.í µí±…í µí±œí µí±™í µí±’.

Deductive reasoning rules relate to operational semantics that describes the evolution of a session. They are used to verify the state reachability of service choreography. Every deductive reasoning rule is a Horn clause in the following form: IF âŸ¨antecedentâŸ© THEN âŸ¨consequentâŸ©, where the antecedent is a conjunction of one or more clauses and the consequent is an assertion of facts.
The relation SessionDeduction defines deduction of session evolution. If the precondition í µí± holds and the session í µí±† executes an atomic session í µí± making í µí±† become the session í µí±†í® í° , then í µí±† is deduced to í µí±†í® í° . In particular, the two sessions can be identified by two states, before and after evolution.
Choreography model checking may concern two kinds of state. One is the session state that defines whether a session can normally end and successfully complete its job. The other is the application state that defines whether an application that is running on one or more sessions can normally end. As a session will never end until all atomic sessions end, the state space of a session is determined by all possible states of the atomic sessions. Similarly, the state space of an application is determined by all possible states of the sessions.

Definition 8 (state reachability). A state (session state) is reachable provided that there is an evolving session which can be identified by the state and which can be deduced from its ancestor in its initial state.

Inference 1. If the termination states of an application described by a choreography model are reachable, that is, the termination sessions (denoted as NULL) can be deduced from the initial sessions, then all states of the application are reachable and the choreography models are thereby proven correct.

The basic deductive reasoning rules are listed as follows: (i)

í µí±…atom : í µí± í®í®tí¸€rí¸€í®uí¸€í®eâ†’,í¸€í µí± í µí±í µí±ˆí µí°¿í µí°¿

(8)

(ii)

í µí±…í µí± í µí±¡í µí±Ÿí µí±¢í µí±í µí±¡

:

í µí±†

â‰¡

í µí±†í® í° 

í µí±,í µí±
í µí±† í®í®í¸€â†’í¸€ í µí±‡ í µí±‡

í µí±†í® í° 

í µí±,í µí±
í®í®í¸€â†’í¸€

í µí±‡í® í° 

â‰¡

í µí±‡í® í° 

(9)

(iii)

í µí±…seq1 : í µí± â‹… í µí±† í®í®tí¸€rí¸€í®uí¸€í®eâ†’,í¸€í µí± í µí±†

(10)

(iv)

í µí±…seq2

:

í µí±† í µí±† â‹… í µí±‡

í µí±,í µí±
í®í®í¸€â†’í¸€
í µí±,í µí±
í®í®í¸€â†’í¸€

í µí±†í® í°  í µí±†í® í° 

â‹… í µí±‡

(11)

Mathematical Problems in Engineering

7

(v)

í µí±…parallel

:

í µí±† í µí±† â€–í µí±‡

í µí±,í µí±
í®í®í¸€â†’í¸€
í µí±,í µí±
í®í®í¸€â†’í¸€

í µí±†í® í°  í µí±†í® í°  â€–í µí±‡

(12)

(vi)

í µí±…choice

:

í µí±†1 í®í®í µí¸€í±í¸€1í®â†’,í¸€í µí± í µí±†1í® í°  [í µí±1] í µí±†1 + [í µí±2] í µí±†2 í®í®í µí¸€í±í¸€í®1â†’,í¸€í µí±

í µí±†1í® í° 

(13)

(vii)

í µí±…nonblock

:

í µí±† í®Â¬í®í¸€í¸€í µí®í±í¸€í µí®í±”,í¸€í®Ní¸€í®Uí¸€í®Lâ†’í¸€L í µí±† [í µí±í µí±”] [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† í®Â¬í®í¸€í¸€í µí®í±í¸€í µí®í±”,í¸€í®Ní¸€í®Uí¸€í®Lâ†’í¸€L

í µí±í µí±ˆí µí°¿í µí°¿

(14)

(viii)

í µí±…norepeat

:

í µí±† í®í®í µí¸€í±í¸€í®í µí±”í¸€âˆ§í®í¸€Â¬í®í¸€í®í µí±í¸€í®reí¸€pí®â†’,í¸€í µí± í µí±†í® í°  [í µí±í µí±”] [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† í®í®í µí¸€í±í¸€í®í µí±”í¸€âˆ§í®í¸€Â¬í®í¸€í®í µí±í¸€í®reí¸€pí®â†’,í¸€í µí±

í µí±†í® í° 

(15)

(ix)

í µí±…repeat

:

í µí±† í®í®í µí¸€í±í¸€í®í µí±”í¸€âˆ§í®í¸€í®í µí±í¸€rí®eí¸€pí®â†’,í¸€í µí± í µí±†í® í°  [í µí±í µí±”] [í µí±rep] âˆ— í µí±† í®í®í µí¸€í±í¸€í®í µí±”í¸€âˆ§í®í¸€í®í µí±í¸€rí®eí¸€pí®â†’,í¸€í µí± í µí±†í® í° 

â‹… [í µí±rep] âˆ— í µí±†

(16)

í µí±…í µí±í µí±¡í µí±œí µí±š is the rule that holds the indivisibility of an atomic session. í µí±…í µí± í µí±¡í µí±Ÿí µí±¢í µí±í µí±¡ is the rule that keeps the congruence in session deduction. í µí±…í µí± í µí±’í µí±1 and í µí±…í µí± í µí±’í µí±2 are the deduction rules for the sequence sessions. í µí±…í µí±í µí±í µí±Ÿí µí±í µí±™í µí±™í µí±’í µí±™ is the deduction rule for parallel session that two sessions are parallel executed and one of
them evolves. í µí±…í µí±â„í µí±œí µí±–í µí±í µí±’ is the deduction rule for the choice session that if the precondition is true and the atomic session
is executed, one of the two sessions will evolve. í µí±…í µí±›í µí±œí µí±›í µí±í µí±™í µí±œí µí±í µí±˜ is the deduction rule for the workunit that if the precondition
is false and [í µí±í µí±”][í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† works in nonblocking mode, the workunit will be skipped. í µí±…í µí±›í µí±œí µí±Ÿí µí±’í µí±í µí±’í µí±í µí±¡ is the deduction rule for the workunit that if í µí±í µí±” is â€œtrueâ€ and í µí±í µí±Ÿí µí±’í µí± is â€œfalseâ€ í µí±† will become í µí±†í® í°  and the workunit will become í µí±†í® í°  after execution
of í µí±. í µí±…í µí±Ÿí µí±’í µí±í µí±’í µí±í µí±¡ is the deduction rule for the workunit that if both í µí±í µí±” and í µí±í µí±Ÿí µí±’í µí± are â€œtrueâ€ í µí±† will become í µí±†í® í°  and the workunit will become í µí±†í® í°  â‹… [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† after execution of í µí±, where [í µí±í µí±Ÿí µí±’í µí±] âˆ— í µí±† means if í µí±í µí±Ÿí µí±’í µí± is â€œtrueâ€ then í µí±† will be iteratively executed.

2.2. Application Model of Service Choreography. The metamodel gives a formal definition of the metaconcepts and relations of service choreography and provides fundamental semantics for service choreography description. An application model, an instantiation of the metaconcept model, gives a UML-compliant description and representation of service choreography. To build the model, software engineers would start with analysis of the objectives to be achieved in the choreography and then describe the roles that participants implement, the activities that the roles perform, and the session execution patterns.

Definition 9 (application model of service choreography). The application model of service choreography formally describes the design of service choreography for a distributed application in a UML-compliant representation within the constraint of the metamodel. It comprises three parts: âŸ¨AppConcept, AppRelation, AppFunctionâŸ©.
AppConcept is a finite set of application concepts which are defined by instantiating the metaconcepts of the metamodel. AppRelation is a finite set of application relations which are defined by instantiating the metarelations of the metamodel. AppFunction is a set of functions that map AppConcept to MetaConcept or AppRelation to MetaRelation in order to trace the types of application concepts and relations in the metamodel. For example, Buyer is an AppConcept and Role is the corresponding MetaConcept, and thus the function is built as follows: AppFunction(Buyer) = Role.
The application model, if built with a universal UML tool, may suffer from the problems of inconsistency, incompleteness, and unreachable states, as mentioned in Section 2.1.3. The next section will discuss the technique of transforming the UML-based model into DL ontology to verify the correctness of the model with the help of a popular reasoner.
3. Model Transformation and Verification
UML is a semiformal specification language and it does not by itself support logic inference for model checking. A popular solution is to use OCL (Object Constraint Language), a subset of UML for defining domain constraints in firstorder predicate logic for model checking. Unfortunately, it is well known that the full expressiveness of OCL may lead to undecidability of reasoning [21]. As a result, the existing methods have to either limit the UML/OCL constructs or decrease the level of automation or balance between the two.
To solve the problem, we suggest using SHOIN(D), the subsystem of DL, to formalize the models. DL is proven powerful in expressibility and decidability for knowledge engineering and allows for making use of some handy reasoning engines, such as Pellet and Racer. But engineers may worry about the fact that it is hard to learn a formal language, hoping that the formal language would be hidden by a software tool.
This section will discuss the algorithms for model transformation, the mechanism of model verification based on SHOIN(D), and the way of implementing prototype.
3.1. Mechanism for Service Choreography Model Verification Based on SHOIN(D). In the early stage of our research, we obtained some meaningful achievements in DL-based reasoning. Dong et al. [22, 23] checked the C4ISR (Command, Control, Communication, Computer, Intelligence, Surveillance, and Reconnaissance) domain models to guarantee the consistency and completeness through converting the UML models into the Description Logic ontology and making use of inference engine Pellet. He et al. [24] presented a method of UML behavioral model verification based on Description Logic system. He et al. transformed UML behavioral models to OWL DL ontology, and hence model consistency can be

8

Mathematical Problems in Engineering

Service choreography model

Service choreography metaconcept model

Guide and constraint

Domain expert

Build
Conversed into

Service choreography app concept model
Conversed into

DL system

Tbox

Abox

Model checking results

Reasoning engine

Figure 3: Mechanism for service choreography model verification based on SHOIN(D).

verified with DL supporting reasoner. Zhang [25] tried to transform the service-oriented application models to OWL DL ontology. Based on the above research, we present, as shown in Figure 3, a mechanism for service choreography model verification based on SHOIN(D).
The principle of conversion and verification is as follows: (1) convert the metaconcepts of service choreography model and domain rules into the axiom sets in SHOIN(D) Tbox and the application concept model into the assertion sets in SHOIN(D) Abox; (2) verify the consistency, completeness, and state reachability with the help of a reasoning engine like Pellet that supports logical reasoning through the SHOIN(D) ontology. The automatic conversion can be realized by Algorithms 1 and 2.
Step (1) initializes Tbox and Abox. Steps (2)â€“(10) convert the metaconcepts and relations of the metaconcept model into axiom sets in Tbox. Steps (11)â€“(17) add multiplicity constraints of metarelations as axiom sets in Tbox. Subsequently, steps (18)â€“(24) convert application concepts and relations of the application model into assertion sets in Abox. For a more detailed explanation for each step, refer to our previous work in [22, 24]. Our previous work [23] showed that the conversion is correct and there is no semantics loss.
The domain rules need to be transformed into axiom sets in Tbox. The consistency and completeness rules are specified in DL and can be added to Tbox through steps (11)â€“ (17), while the deductive reasoning rules need to be specified in SWRL. SWRL combines RuleML and OWL DL. It is popularly applied for formal representation of semantic rules and knowledge-based reasoning, supported by the algorithm Tableau [15].
Algorithm 2 is provided to convert the deductive reasoning rules in the choreography model into the formally specified rules in SWRL.

The concepts and relations appearing in the prerequisite of the deductive reasoning rules are converted to Horn clauses that combine to form the antecedent of SWRL rules, and the concepts and relations appearing in the conclusion are converted to Horn clauses that combine to form the consequent of SWRL rules.
For example, the deductive reasoning rules í µí±…í µí±í µí±¡í µí±œí µí±š and í µí±…í µí± í µí±¡í µí±Ÿí µí±¢í µí±í µí±¡ are converted into following SWRL expressions:
(i) í µí°ºí µí±¢í µí±í µí±Ÿí µí±‘ (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±ƒí µí±Ÿí µí±’í µí±í µí±œí µí±›í µí±‘í µí±–í µí±¡í µí±–í µí±œí µí±› í µí±)

âˆ§ í µí°¸í µí±¥í µí±í µí±¢í µí±¡í µí±–í µí±›í µí±” (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±†í µí±í µí±¡í µí±œí µí±š í µí±) âˆ§ í µí°µí µí±œí µí±œí µí±™í µí±’í µí±í µí±› (í µí±ƒí µí±Ÿí µí±’í µí±í µí±œí µí±›í µí±‘í µí±–í µí±¡í µí±–í µí±œí µí±› í µí±, í µí±¡í µí±Ÿí µí±¢í µí±’)

í®í¸€â†’ í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±›í µí°·í µí±’í µí±‘í µí±¢í µí±í µí±¡í µí±–í µí±œí µí±› (í µí±†í µí±í µí±¡í µí±œí µí±š í µí±, í µí±í µí±ˆí µí°¿í µí°¿) (ii) í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±›í µí°·í µí±’í µí±‘í µí±¢í µí±í µí±¡í µí±–í µí±œí µí±› (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±‡)
âˆ§ í µí°¶í µí±œí µí±›í µí±”í µí±Ÿí µí±¢í µí±’í µí±›í µí±í µí±’ (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†í® í° )

âˆ§ í µí°¶í µí±œí µí±›í µí±”í µí±Ÿí µí±¢í µí±’í µí±›í µí±í µí±’ (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±‡, í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±‡í® í° )

(17)

âˆ§ í µí°ºí µí±¢í µí±í µí±Ÿí µí±‘ (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±ƒí µí±Ÿí µí±’í µí±í µí±œí µí±›í µí±‘í µí±–í µí±¡í µí±–í µí±œí µí±› í µí±)

âˆ§ í µí°¸í µí±¥í µí±’í µí±í µí±¢í µí±¡í µí±–í µí±›í µí±” (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†, í µí±†í µí±í µí±¡í µí±œí µí±š í µí±) âˆ§ í µí°µí µí±œí µí±œí µí±™í µí±’í µí±í µí±› (í µí±ƒí µí±Ÿí µí±’í µí±í µí±œí µí±›í µí±‘í µí±–í µí±¡í µí±–í µí±œí µí±› í µí±, í µí±¡í µí±Ÿí µí±¢í µí±’) í®í¸€â†’ í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±›í µí°·í µí±’í µí±‘í µí±¢í µí±í µí±¡í µí±–í µí±œí µí±› (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†í® í° , í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±‡í® í° ) âˆ§ í µí°ºí µí±¢í µí±í µí±Ÿí µí±‘ (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†í® í° , í µí±ƒí µí±Ÿí µí±’í µí±í µí±œí µí±›í µí±‘í µí±–í µí±¡í µí±–í µí±œí µí±› í µí±) âˆ§ í µí°¸í µí±¥í µí±’í µí±í µí±¢í µí±¡í µí±–í µí±›í µí±” (í µí±†í µí±’í µí± í µí± í µí±–í µí±œí µí±› í µí±†í® í° , í µí±†í µí±í µí±¡í µí±œí µí±š í µí±)

Mathematical Problems in Engineering

9

Input: the meta model and the application model Output: Tbox, Abox begin (1) Tbox = { }, Abox = { }; (2) for all MetaConcepts í µí°¶ in meta concept model, do (3) Tbox = Tbox âˆª {í µí±}; (4) if í µí°¶2 is the superclass of í µí°¶1, then
Tbox = Tbox âˆª {í µí±1 âŠ‘ í µí±2}; (5) else if í µí°¶ has a data attribute í µí±‹ (data type is í µí±¡), then
Tbox = Tbox âˆª {í µí± âŠ‘ í µí±¥ â‹… í µí±¡}; (6) else if í µí°¶1 =Ì¸ í µí°¶2 and í µí°¶1 âŠ‘ í µí°¶2 âˆ‰ Tbox
and í µí°¶2 âŠ‘ í µí°¶1 âˆ‰ Tbox, then Tbox = Tbox âˆª {í µí±1 âŠ“ í µí±2 = âŒ€}; (7) end if; (8) end for; (9) for all MetaRelation í µí±… = (í µí°¶1, í µí°¶2) in meta concept model, the relation í µí±Ÿ âˆ¼ is the inverse relation of í µí±Ÿ, do Tbox = Tbox âˆª {í µí±1 âŠ‘ âˆ€í µí±Ÿ â‹… í µí±2, í µí±2 âŠ‘ âˆ€í µí±Ÿâˆ¼ â‹… í µí±1}; (10) end for; (11) for all the multiplicity constraints in range and domain of every relation í µí±… = (í µí°¶1, í µí°¶2) in meta concept model, the relation í µí±Ÿ âˆ¼ is the inverse relation of í µí±Ÿ, do (12) if multiplicity constraints is â€œ0 â‹… â‹… â‹… 1â€ then Tbox = Tbox âˆª {í µí±1 âŠ‘â‰¤ 1í µí±Ÿ â‹… í µí±2} âˆª {í µí±2 âŠ‘â‰¤ 1í µí±Ÿâˆ¼ â‹… í µí±1}; (13) else if multiplicity constraints is â€œ1 â‹… â‹… â‹…âˆ—â€ then Tbox = Tbox âˆª {í µí±1 âŠ‘â‰¥ 1í µí±Ÿ â‹… í µí±2} âˆª {í µí±2 âŠ‘â‰¥ 1í µí±Ÿâˆ¼ â‹… í µí±1}; (14) else if multiplicity constraints is â€œ1â€ then Tbox = Tbox âˆª {í µí±1 âŠ‘â‰¤ 1í µí±Ÿ â‹… í µí±2, í µí±1 âŠ‘â‰¥ 1í µí±Ÿ â‹… í µí±2} âˆª {í µí±2 âŠ‘â‰¤ 1í µí±Ÿâˆ¼ â‹… í µí±1, í µí±2 âŠ‘â‰¥ 1í µí±Ÿâˆ¼ â‹… í µí±1}; (15) end if; (16) end for; (17) return Tbox; (18) for all individuals í µí±œ in application concept model, (19) if AppFunction(o) = c, do Abox = Abox âˆª {í µí±œ} âˆª {í µí±œ : í µí±}; (20) end for; (21) for all individuals í µí±1, í µí±2 in application concept model, (22) if AppFunction(r) = R, do Abox = Abox âˆª {í µí±1} âˆª {í µí±2} âˆª {âŸ¨í µí±1, í µí±2âŸ© : í µí±Ÿ}; (23) end for; (24) return Abox; end
Algorithm 1: Construct SHOIN(D) Tbox&Abox.

3.2. Prototype Implementation. Algorithms 1 and 2 have been realized and integrated into our requirement analysis tool, the so-called ontology-based requirements elicitation and analysis tool (OBREAT) [25]. The architecture of OBREAT and the major components can be found in Figure 4.
The presentation layer handles the interaction between users and the application. It checks and takes user input, as well as feedbacks on execution information including reasoning results. Currently, there are a variety of modeling notations, such as UML [26â€“31], Message Sequence Charts (MSCs) [32], and BPMN [33, 34], to visually model the choreography interaction. In our research, the UML class diagrams and collaboration diagrams (or Communication Diagrams in [35]) are preferred for the presentation of service choreography models from structural and behavioral viewpoint, respectively, taking the advantages of rigorous syntax and semantics, easiness to interpret, and various tools such as RSA, EA, and Rose to share some part of models.

As the core component of the architecture, the logic layer processes modeling transactions and submits results to the presentation layer, and it also communicates with the data layer for data persistency. The DL-based Formal Model Generator handles the model conversion with the algorithms mentioned before. The output of the generator is sent to the Model Feature Reasoner and then is saved in Formal Model database. The Model Feature Reasoner communicates with DL reasoner Pellet to complete DL-based reasoning and sends the results to the Execution Control Interface. At present, the Model Feature Reasoner realizes checking the property of consistency, completeness, and state reachability. Specifically, the results are also exported to the Domain Knowledge base to enrich domain knowledge for reuse and thus knowledge reusability is continuously enhanced with knowledge accumulation.
The data layer handles data persistency and maintenance. Most of the input/output data are saved as files, either model

10

Mathematical Problems in Engineering

Input: Deductive reasoning rules for service choreography model Output: Deductive reasoning rules based on SWRL, í µí±…SWRL Begin
Antecedent = { }, Consequent = { }, Clause = { }; for all concepts í µí°¶ and relations í µí±… in prerequisite and conclusion, if í µí°¶1, í µí°¶2 has í µí±… relation, í µí±1, í µí±2 are individuals of í µí°¶1, í µí°¶2, then
Clause = Clause âˆª {í µí±…(í µí°¶1í µí±1, í µí°¶2í µí±2)}; else if í µí°¶ has a attribute í µí±ƒ (type is í µí±¡), then
Clause = Clause âˆª {í µí±ƒ(í µí°¶í µí±, í µí±¡)}; end for; for all clauses cl do
if relation between cl is â€œandâ€ in prerequisite then Antecedent = Antecedent âˆª {cl1 âˆ§ cl2}; else if relation between cl is â€œorâ€ in prerequisite then Antecedent = Antecedent âˆª {cl1 âˆ¨ cl2}; else if relation between cl is â€œandâ€ in conclusion then Consequent = Consequent âˆª {cl1 âˆ§ cl2}; else if relation between cl is â€œorâ€ in conclusion then Consequent = Consequent âˆª {cl1 âˆ¨ cl2}; end if; end for; í µí±…SWRL = Antecedent âˆª Consequent; return í µí±…SWRL; end
Algorithm 2: Construct í µí±…SWRL.

Gui modeling interface Metaconcept model modeling interface
Refers to

App concept model modeling interface

Execution Control Interface
Command input/ results enquiry

Presentation layer

Metafile editor

Updates model file via

Model file operator

Convert model to DL-based one via

Read/write

Model file

Metaconcept App concept

model

model

Requirements specification document

Model Feature Reasoner

Send DL-based service choreography model to

Enrich domain knowledge into/ call formal data from

Save generated Dl-based Formal formal model to
Model Generator

Formalized file manager

Import/export Formalized file

Logic layer Data layer

System Administration
Database

Domain

Formal Model

knowledge

Figure 4: Architecture of service hierarchy of OBREAT.

files or formalized files, while model management data are saved in the database System Administration Database.
For the sake of model exchange, we adopt XML as the model data description language. Since the DL-based reasoner accepts data only in OWL which is somewhat different from XML, the conversion between two types of

XML documents is needed. To automate the conversion, we choose the eXtensible Stylesheet Language Transformation (XSLT) technology [36, 37] which is widely used for XML document conversion. We designed a set of XSLT transformation templates compliant with the Ontology Definition Metamodel (ODM) and the UML profile. Moreover, we

Mathematical Problems in Engineering

11

integrate MagicDraw [38] in OBREAT as the GUI modeling tool in the presentation layer and Pellet 1.5.0 as the DL-based reasoner in the logic layer for verification reasoning.
4. Case Study
In this section, a simplified case of purchase order application of the e-commerce system is studied, illustrating how to construct the application model and how to realize the model verification.
4.1. Construction of Application Model. Limited by the page size, the choreography of the purchase order application is simplified here, and it covers only a few main activities: the buyer sends an order request to the seller, and then the seller checks the buyerâ€™s credit record in the bank and the supplier

inventory. If the credit record is good and the inventory is sufficient, then the order will be accepted; otherwise, it will be rejected.
The above activities are encapsulated into five sessions: purchase order request (í µí±† í µí±í µí±œí µí±…í µí±’í µí±), credit check (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’), inventory check (í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’), purchase order response (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±), and purchase order reject (í µí±† í µí±í µí±œí µí±…í µí±’í µí±—), where there are four participant roles: Buyer, Seller, Bank, and Supplier.
The buyer initiates an interaction with the seller by placing a purchase order po through the channel Ch@Seller, and then the seller acknowledges the buyer by sending him a poAck. Meanwhile, the states of the purchase orders of Buyer and Seller are set to â€œsentâ€ and â€œreceived,â€ respectively. Accordingly, the session í µí±† í µí±í µí±œí µí±…í µí±’í µí± is composed of four atomic sessions which are specified as follows and is modeled as a UML class diagram in Figure 5:

í µí±† í µí±í µí±œí µí±…í µí±’í µí± = í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œ í®í¸€â†’ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œ, í µí°¶â„@í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ)

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜ â†í®í¸€ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜, í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ)

(18)

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡")

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

The other four sessions function as follows: í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ checks the buyerâ€™s credit by sending a request to the bank that sends back the state of the credit (good or bad); í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ checks the sellerâ€™s inventory by sending a request to the seller who sends back the state of the inventory (sufficient or short);

í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± declares that the order has been accepted if the buyerâ€™s credit is good and the inventory is sufficient; and í µí±† í µí±í µí±œí µí±…í µí±’í µí±— declares that the order has been rejected if the buyerâ€™s credit is bad or the inventory is short. The four sessions are specified as follows, while the related class models are omitted due to space limitation:

í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ = í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±Ÿí µí±’í µí±-í µí±Ÿí µí±’í µí± í µí±(í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í®í¸€â†’ í µí°µí µí±í µí±›í µí±˜.í µí±í µí±í µí±…í µí±’í µí±, í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± â†í®í¸€ í µí°µí µí±í µí±›í µí±˜.í µí±í µí±í µí±…í µí±’í µí± í µí±, í µí°¶â„@í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ)
â‹…í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± = "í µí±”í µí±œí µí±œí µí±‘"/"í µí±í µí±í µí±‘") â‹…í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±í µí±›í µí±˜.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí°µí µí±í µí±›í µí±˜.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡") â‹…í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ = í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±Ÿí µí±’í µí±-í µí±Ÿí µí±’í µí± í µí±(í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í®í¸€â†’ í µí±†í µí±¢í µí±í µí±í µí±™í µí±–í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí±,

í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± â†í®í¸€ í µí±†í µí±¢í µí±í µí±í µí±™í µí±–í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí±, í µí°¶â„@í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ)

â‹…í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± = "í µí± í µí±¢í µí±“í µí±“í µí±–í µí±í µí±–í µí±’í µí±›í µí±¡"/"í µí± â„í µí±œí µí±Ÿí µí±¡")

â‹…í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±¢í µí±í µí±í µí±™í µí±–í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí±†í µí±¢í µí±í µí±í µí±™í µí±–í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡")

(19)

â‹…í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± = í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±Ÿí µí±’í µí± í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±…í µí±’í µí± í µí± â†í®í¸€ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±…í µí±’í µí± í µí±, í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ) â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±í µí±œí µí±ší µí±í µí±™í µí±’í µí±¡í µí±’í µí±‘") â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±í µí±œí µí±ší µí±í µí±™í µí±’í µí±¡í µí±’í µí±‘")

í µí±† í µí±í µí±œí µí±…í µí±’í µí±— = í µí±† í µí±í µí±œí µí±…í µí±’í µí±— í µí±Ÿí µí±’í µí± í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±…í µí±’í µí± í µí± â†í®í¸€ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±…í µí±’í µí± í µí±, í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ) â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí±— í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±¢í µí±›í µí±í µí±œí µí±ší µí±í µí±™í µí±’í µí±¡í µí±’í µí±‘") â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí±— í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±¢í µí±›í µí±í µí±œí µí±ší µí±í µí±™í µí±’í µí±¡í µí±’í µí±‘")

12
Class choreography [ purchase order service choreography]

Mathematical Problems in Engineering

â€œAtomicSessionâ€ S_poReq_assign_Buyer +Name : String -Buyer_poState : String
Â·Â·Â· +poReq_assign_Buyer()
â€œRoleâ€ Buyer -po : String -poAck : String -poState : String -poResp : String

â€œSessionâ€
S_poReq
+Name : String -Precondition : Boolean = true #Var : String
Â·Â·Â·
+poReq_req() +poReq_resp() +poReq_assign_Buyer() +poReq_assign_Seller()

â€œAtomicSessionâ€ S_poReq_assign_Seller
+Name : String -Seller_poState : String
Â·Â·Â·
+poReq_assign_Seller()

â€œAtomicSessionâ€ S_poReq_req
+Name : String -po : String
Â·Â·Â·
+poReq_req()

â€œAtomicSessionâ€ S_poReq_resp
+Name : String -poAck : String
Â·Â·Â·
+poReq_resp()

â€œRoleâ€
Seller
-po : String -poAck : String -poState : String -ccReq : String -ccResp : String -ccState : String -icReq : String -icResp : String -icState : String -poResp : String

Figure 5: Structure of S poReq.

The interaction sequence companied with the participants and key messages can be modeled as a UML communication diagram, as shown in Figure 6.
Having analyzed the interaction and the functions of the sessions, we can organize the choreography of the purchase order application as follows:

í µí°¶â„í µí±œ í µí±í µí±œ = í µí±† í µí±í µí±œí µí±…í µí±’í µí± â‹… (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ â€– í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’) (20)
â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)
and specify the preconditions of the sessions as follows:

í µí±ƒ í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ = í µí± í µí±–í µí±›Ví µí°¶â„í µí±’ = (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡" âˆ§ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘") ;
í µí±ƒ í µí±í µí±œí µí±…í µí±’í µí± í µí± = (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± = "í µí±”í µí±œí µí±œí µí±‘" âˆ§ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± = "í µí± í µí±¢í µí±“í µí±“í µí±–í µí±í µí±–í µí±’í µí±›í µí±¡" (21)
âˆ§ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘");
í µí±ƒ í µí±í µí±œí µí±…í µí±’í µí±— = (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± = "í µí±í µí±í µí±‘" âˆ¨ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± = "í µí± â„í µí±œí µí±Ÿí µí±¡" âˆ§ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘").

Furthermore, the SHOIN(D) ontology can be generated axiom set in Tbox and the instance set in Abox are listed as by the algorithm Construct Tbox&Abox, and as a result, the in Table 3.

Mathematical Problems in Engineering

13

4.2. Verification of Application Model. Having constructed the application model which is subsequently converted into the SHOIN(D) ontology, we can check the correctness properties of consistency, completeness, and state reachability of the specified choreography separately in the following cases.
Case 1 (consistency checking). Consistency checking is to check whether there is a conceptual conflict against modeling semantics; that is, giving a group of related concepts in the application model, the relationships defined between the concepts should semantically abide by the metarelation declared in the metamodel.
Suppose that the modeler tries to add in the application model a relation of Executing between the Role Buyer and the session S poReq. But according to the constraints of the metamodel, such relation should only appear between two sessions and thus the consistency rule í µí±…í µí±í µí±œí µí±›1 is broken. The error can be easily found through ontology consistency checking using Pellet.
Case 2 (completeness checking). The completeness checking is to check whether there is a lack of concept or relation in the application model; that is, giving a group of related concepts, the relationships defined between the concepts

should quantitatively abide by the multiplicity constraint of the corresponding metarelation in the metamodel.
Suppose that the modeler tries to build a Belong to relation between the Role Supplier and the Participant ProductTrader, meaning that Supplier belongs to a product trader, but wrongly add at the same time another Belong to relation between Supplier and ServiceProvider. Such relation violates the multiplicity constraint í µí±…í µí±í µí±œí µí±›1 that means each Role must belong to only one Participant at any time. The checking result is prompted by Pellet as follows: â€œConsistent: No Reason: The individual Supplier has more than one value for property Belong to violating the cardinality restriction.â€
Case 3 (state reachability checking). The state reachability checking is to examine whether the termination state of a session defined in the application model is reachable; that is, the session can be deduced using the deductive reasoning rules given in Section 2.1.3. If all sessions are deducible, implying that all session states are reachable, the application behavior is verified.
Session S poReq is deduced with the deductive reasoning rules í µí±…í µí±í µí±¡í µí±œí µí±š and í µí±…í µí± í µí±’í µí±2 and as a result, poState of Buyer will be set to â€œsentâ€ and the poState of Seller will be set to â€œreceived.â€ The reasoning process is shown as follows:

í µí±† í µí±í µí±œí µí±…í µí±’í µí± = í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œ í®í¸€â†’ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œ, í µí°¶â„@í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ) â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜ â†í®í¸€ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜, í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ) â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡") â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±¡í µí±Ÿí µí±¢í µí±’, í µí±=í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí±(í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œ â†’ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œ,í µí°¶â„@í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ)
í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€

í µí±í µí±ˆí µí°¿í µí°¿

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± í µí± (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜ â†í®í¸€ í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜, í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ)

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡")

â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±¡í µí±Ÿí µí±¢í µí±’, í µí±=í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± í µí±(í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜â†í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí°´í µí±í µí±˜,í µí°¶â„@í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ)

(22)

í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€

í µí±í µí±ˆí µí°¿í µí°¿ â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ (í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí± í µí±’í µí±›í µí±¡") â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±sí µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±¡í µí±Ÿí µí±¢í µí±’, í µí±=í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ(í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’="í µí± í µí±’í µí±›í µí±¡")
í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€

í µí±í µí±ˆí µí°¿í µí°¿ â‹…í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ (í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’ = "í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")

í µí±¡í µí±Ÿí µí±¢í µí±’, í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ(í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’="í µí±Ÿí µí±’í µí±í µí±’í µí±–Ví µí±’í µí±‘")
í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€

í µí±í µí±ˆí µí°¿í µí°¿

14

Mathematical Problems in Engineering

The other four sessions credit check (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’), inventory check (í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’), purchase order response (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±), and purchase order reject (í µí±† í µí±í µí±œí µí±…í µí±’í µí±—) can be deduced in the
same way.

The whole reasoning process for the application choreography model í µí°¶â„í µí±œ í µí±í µí±œ is shown as follows, where
the deduction rules applied to each step are bracketed with âŸ¨ âŸ©:

í µí°¶â„í µí±œ í µí±í µí±œ = í µí±† í µí±í µí±œí µí±…í µí±’í µí± â‹… (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ â€– í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’) â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

í®í®í¸€í¸€í®í¸€í®í µí±¡í µí¸€í®í±Ÿí µí¸€í±¢í®í µí¸€í±’í®,í¸€í®í µí±í¸€âˆ—í®í¸€í®â†’í¸€ í µí±í µí±ˆí µí°¿í µí°¿ â‹… (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ â€– í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’) â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí±…í µí±í µí±¡í µí±œí µí±š, í µí±…í µí± í µí±’í µí±2âŸ©

í®í®í¸€í¸€í®â†’í¸€ (í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ â€– í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’) â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí°¶6 âŸ©
í®í µí®í¸€í±ƒí¸€í®í µí¸€í®í±í µí±Ÿí¸€í®í µí±’í¸€í µí®í±‘í¸€í µí®í°¶í¸€â„í®í¸€í µí®í±’,í¸€í®í µí¸€í±í®âˆ—â†’í¸€âˆ— (í µí±í µí±ˆí µí°¿í µí°¿ â€– í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’) â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí±…í µí±í µí±¡í µí±œí µí±š, í µí±…í µí±í µí±í µí±Ÿí µí±í µí±™í µí±™í µí±’í µí±™âŸ©

(23)

í®í®í¸€í¸€í®â†’í¸€ í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí°¶5 âŸ© í µí± í µí±–í µí±›Ví µí°¶â„í µí±’, í µí±âˆ—âˆ—âˆ—
í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€ í µí±í µí±ˆí µí°¿í µí°¿ â‹… (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí±…í µí±í µí±¡í µí±œí µí±š, í µí±…í µí± í µí±’í µí±2âŸ©

í®í®í¸€í¸€í®â†’í¸€ (í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± + í µí±† í µí±í µí±œí µí±…í µí±’í µí±—)

âŸ¨í µí°¶6 âŸ© í µí±ƒ í µí±í µí±œí µí±…í µí±’í µí± í µí±, í µí±âˆ—âˆ—âˆ—âˆ—
í®í®í¸€í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®í¸€í®â†’í¸€ í µí±í µí±ˆí µí°¿í µí°¿

The atomic sessions in each step are as follows: í µí±âˆ— = í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± â‹… í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±Ÿí µí±’í µí± í µí±
â‹… í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ
â‹… í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ
í µí±âˆ—âˆ— = í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±Ÿí µí±’í µí±-í µí±Ÿí µí±’í µí± í µí±
â‹… í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí±
â‹… í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±í µí±›í µí±˜.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’
â‹… í µí±† í µí±í µí±Ÿí µí±’í µí±‘í µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’ (24)
í µí±âˆ—âˆ—âˆ— = í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±Ÿí µí±’í µí±-í µí±Ÿí µí±’í µí± í µí±
â‹… í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí±
â‹… í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±¢í µí±í µí±í µí±™í µí±–í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’
â‹… í µí±† í µí±–í µí±›Ví µí°¶â„í µí±’ í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±†í µí±¡í µí±í µí±¡í µí±’
í µí±âˆ—âˆ—âˆ—âˆ— = í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±Ÿí µí±’í µí± í µí±
â‹… í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí°µí µí±¢í µí±¦í µí±’í µí±Ÿ.í µí±í µí±œí µí±†í µí±¡í µí±í µí±¡í µí±’
â‹… í µí±† í µí±í µí±œí µí±…í µí±’í µí± í µí± í µí±í µí± í µí± í µí±–í µí±”í µí±› í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±oí µí±†í µí±¡í µí±í µí±¡í µí±’
The application behavior is proven correct provided that the reasoning process may eventually end by NULL. Otherwise, there must be a session failed to be deduced (i.e., its termination state is not reachable). If the application may reach the final state, the key attribute poState of both Buyer and Seller will be set to either â€œcompletedâ€ or â€œuncompletedâ€ (this may happen when í µí°µí µí±¦í µí±¢í µí±’í µí±Ÿ.í µí±í µí±í µí±…í µí±’í µí± í µí± = "í µí±í µí±í µí±‘" or í µí±†í µí±’í µí±™í µí±™í µí±’í µí±Ÿ.í µí±–í µí±í µí±…í µí±’í µí± í µí± = "í µí± â„í µí±œí µí±Ÿí µí±¡").
To give a negative example, we deliberately assign Seller.poState = â€œâ€ to make false the precondition P credChe. As a result, the reasoning process rests on the second step,

as the session S credChe cannot be deduced, and therefore all states of the sessions followed cannot be reached. The exception can be found by entering the following DL-based query command in the form of SPARQL [24]:
SELECT ? a WHERE {? a rdf:type xmlns: Session.? a xmlns: SessionDeduction ? NULL.}.
Figure 7 shows the query result in the human interface panel of the reasoner Pellet, indicating that the session S poReq and its four atomic sessions are deduced (or can be successfully executed), while all of the subsequent sessions are not shown (or the corresponding states of these sessions may not be reached). The rules âŸ¨í µí±…í µí±í µí±¡í µí±œí µí±š, í µí±…í µí± í µí±’í µí±2âŸ© are applied to the reasoning process to find the exception where the SessionDeduction relation is broken between the sessions S poReq and S credChe and all of the followed sessions cannot be deduced.
Beside the above experiment, we have also modeled and verified several other cases, including the online shopping example given in [39], the buyer-seller example given in [40], and the example from the supply chain management [41].
The verification is processed efficiently. The reasoning for each case is finished within a second, tested on a laptop computer with a 2 GHz Intel processor and 1 GB of RAM. That accords with the comments by Haarslev and MoÂ¨ller [42] who pointed out that even for the hardest problems the query time for DL reasoning would be within three seconds. But, is it always true?
In order to evaluate the efficiency of reasoning for CMLDL models, we choose the four popular ontologies, VICODI, LUBM, Semintec, and Wine which are used in previous benchmarks, carry out experiment, and lead a statistical analysis by comparing the average response times against the increasing size of Abox. The detailed descriptions about these ontologies can be found in [43].

Mathematical Problems in Engineering

15

Table 3: Axiom set and instances set of purchase order service choreography model (fragment).

Axiom set in Tbox
NoAction âŠ‘ Abas SilentAction âŠ‘ Abas InterAction âŠ‘ Abas Assign âŠ‘ Abas Perform âŠ‘ Abas Abas âŠ‘ Act Astr âŠ‘ Act í µí±†í µí±í µí±¡í µí±œí µí±š âŠ‘ Session í µí±†í µí±í µí±œí µí±š âŠ‘ Session Session âŠ‘ âˆ€ SessionDeduction.Session Participant âŠ‘ âˆ€ Implement.Role Choreography âŠ‘ âˆ€ Contain.Session Interaction âŠ‘ âˆ€ Depend.Channel Role âŠ‘ âˆ€ Belong to.Participant Interface âŠ‘ âˆ€ Bind.Role Session âŠ‘ âˆ€ Executing. í µí±†í µí±í µí±¡í µí±œí µí±š Session âŠ‘ âˆ€ Sequence. Session Session âŠ‘ âˆ€ Choice. Session ...

Instances set in Abox
S poReq: í µí±†í µí±í µí±œí µí±š S poReq req: í µí±†í µí±í µí±¡í µí±œí µí±š S poReq resp: í µí±†í µí±í µí±¡í µí±œí µí±š S poReq assign Buyer: í µí±†í µí±í µí±¡í µí±œí µí±š S poReq assign Seller: í µí±†í µí±í µí±¡í µí±œí µí±š S credChe: í µí±†í µí±í µí±œí µí±š S poResp: í µí±†í µí±í µí±œí µí±š ProductTrader: Participant
ServiceProvider: Participant
S credChe â€– S invChe S Che: í µí±†parallel S poResp + S poRej: í µí±†choice Cho po: Choreography
Buyer: Role
Supplier: Role
P credChe: Precondition
âŸ¨Cho po, S poReqâŸ©: Contain
âŸ¨S credChe, P credCheâŸ©: Guard
âŸ¨S poReq, S poReq reqâŸ©: Executing
âŸ¨S credChe, S invCheâŸ©: Parallel
âŸ¨S poReq, S credChe â€– S invChe S CheâŸ©: Sequence ...

The ontologies represent four standard benchmark datasets with different complexity. The VICODI ontology is relatively small and simple since it does not contain any disjunctions, existential quantification, or number restrictions. The LUBM ontology and the Semintec ontology are also relatively simple like the VICODI ontology, while the Semintec ontology is more complex since it contains functional properties and disjointness constraints and is constructed using OWL DL. The Wine ontology is the most complex one. It contains a classification of wines and is established using advanced DL constructors.
The above ontologies are too small in Abox for our intended performance evaluations. Therefore, we generate different sizes of datasets, ranging from 100 to 1 million, to increase the Aboxes of the ontologies for test.
To evaluate the query times for various sizes of the datasets, we use several query patterns covering all cases from the simplest one that retrieves all individuals of one concept to the most complex one that retrieves all individuals of the concept. The test method can be referenced by [44].
Figure 8 shows the average time for query response for the four ontologies with the generated datasets sizing from 100 to 1 Mio. All the results reported are averaged over 100 queries. The test is led on a laptop computer with one 2 GHz Intel processor and 1 GB of RAM, running Windows XP Service Pack 4.
As expected, there is a significant increase of query time as the size of the ontology increases from the 100 to 1 million. For the example of the Semintec ontology, the average query time for smaller size from 100 to 10,000 is less than a second (<1). But, the time increases sharply as the size exceeds 10,000, and for the maximum size of 1 Mio., the time is about 800 seconds or about 17 minutes.

Interaction communication in po [ communication in po]
â€œRoleâ€ : Buyer
1: po 2: poAck 7: poResp/poRej

â€œRoleâ€

3: ccReq

: Seller

6: icResp

4: ccResp 5: icReq

â€œRoleâ€ : Bank

â€œRoleâ€ : Supplier

Figure 6: Interaction between roles in the choreography.

Our ontology of CML-DL may match the Semintec ontology since the domain of the CML-DL application is not more complex than that of the financial services, and the model can be constructed using a fragment of OWL DL without advanced DL constructors. Therefore, we expect that the number of individuals of the CML-DL application model, for most projects, would be less than 100000, and thus the reasoning time would be within a few minutes at worst.
5. Related Work Discussion
System verification accounts for a larger proportion in the domain of system engineering. There are two categories:

16

Mathematical Problems in Engineering

Figure 7: The query command window for checking the state reachability.

Response time (s)

10000

1000

100

10

1

0.1

0.01
100 1000 10000 100000 1000000

VICODI

LUBM

Semintec

Wine

0.064

0.058

0.286

0.833

0.081 0.088

0.063 0.086

0.37 0.771

0.942 68.555

0.831

2.072

100.491

998.45

79.451

100.011

800.211

1000.981

Datasets with different individual size

100 1000 10000

100000 1000000

Figure 8: Average query time for the four ontologies (VICODI, LUBM, Semintec, and Wine).

testing and formal verification. Testing is the process in which testers input the use case through access point and then observe the corresponding output to discover potential error. Formal verification, which can be further divided into model checking based on exhausting searching and

model verification based on logic reasoning, expresses system specification by using mathematical methods and then proves whether the designed system meets the desired properties according to mathematical theory.
The initial progress of testing static system properties converts static properties into hard-code and calls these codes during program compilation. Because system specification and system implementation are bounded together, the method does not have flexibility and reusability; that is, when the system static properties to be checked change, the hardcode must be updated as well [45].
The emergence of the open-source projects WS-CDL Eclipse Plugin [46] and Pi4SOA [47] makes it possible to separate system specification and implementation. The engines of these projects provide an execution and simulation environment for WS-CDL documents. When the properties to be checked change, the corresponding descriptions can be revised without any modification to the inspection program. Reference [48] notes that although the WS-CDL is just a description language, it is essentially an XML document; therefore, Eclipse Plugin simulators regard the WS-CDL as executable script language for interpretation and implementation. Nevertheless, the verification methods based on the simulation engine need to traverse the entire value space when handling existential and universal quantifiers, leading to a higher complexity of time and space.
Workflow based web service composition and formal verification techniques are broadly applied. They can be divided into three categories: PN- (Petri Net-) based, FSA(Finite State Automate-) based, and PA- (process algebra-) based techniques.
Xia et al. [49, 50] achieved the complete conversion from a WS-CDL document to stochastic Petri Nets; moreover, they

Mathematical Problems in Engineering

17

Table 4: Comparison between several typical verification methods of service choreography model.

Features

Hard-coding

Description ability

+++

Degree of automation

+

Knowledge reusability

âˆ’

Efficiency of verification

+

State explosion

âˆ’

+: support/existence, âˆ’: nonsupport/nonexistent.

Simulation engine +++ + âˆ’ ++ âˆ’

Methods

Workflow Temporal logic

+

+

++

++

âˆ’

âˆ’

+++

+++

+

+

Abstract WS-CDL + âˆ’ âˆ’ + âˆ’

CMV-DL ++ ++ + +++ âˆ’

make assessments of time expectations, probability, and cost expectations of services that normally end due to the index of performance, reliability, and execution cost, respectively. Foster et al. [51] proposed a type of service modeling and verification method called model-based service compositions engineering for the first time. The method maps the service composition model to a finite state process (FSP), aiming at verifying the compatibility between composite services and their environment by using a labeled transition system analyzer (LTSA). Molina-Jimenez and Shrivastava [52] developed the concept of conformance between a contract and a choreography by assuming that they can be modeled by Finite Automaton (FA). The choreography specifications and contracts, specified by the BPMN notation and the event-condition-action rules, describe permissible interactions between partners from different viewpoints. They established a process to automatically check whether all the behaviors permissible in a choreography are also permissible in the corresponding contract and vice versa. DÂ´Ä±az and Llana [53] mapped the service composition model in WS-CDL to a timed automation and then simulated the dynamic behavior of the system using the automatic verification tool UPPAAL. The literature [54] provided the basis for formalizing and reasoning on the mobility characteristics of web services choreography using the process algebra í µí¼‹calculus which is, according to Robin Milner, a model of concurrent computation based on the notion of naming. They argued that the process algebras, such as í µí¼‹-calculus, can be used to formalize web services characteristics to ensure that they satisfy some conditions required in SOA. SalauÂ¨n et al. [55] presented a method of encoding the collaboration diagrams into the LOTOS process algebra. This encoding allows checking realizability of the collaboration diagrams for both synchronous communication and bounded asynchronous communication.
Gu et al. [8, 9] presented a formal modeling framework Abstract WS-CDL with grammar, congruence relations, and operational semantics. They defined a set of mappings of the Abstract WS-CDL global model to the Pi calculus-based local model and accordingly suggested a set of deductive reasoning rules of state reachability and terminability. Unfortunately, they failed to provide the consistency and completeness verification mechanism as well as the corresponding reasoning engine.
Temporal logic (TL) can be used to assert the behavior change with time evolution. The model verification techniques based on TL model the finite states of systems

with Promela and specify the system properties with TL expressions to enable verification by checking whether the intersection between the Promela models and the TL expressions is empty. Zhang and Liu [56] presented a formal verification method for CCML (Cooperative Composition Modeling Language) based web service composition. They build a mapping of CCML description to CCS expression and approach property verification and service compatibility verification with the help of a TL based checking mechanism and an automated tool.
The above verification methods, either based on workflow or based on TL, may lead an exhaustive search for all states of system execution, which may cause the state explosion problem when the number of the states exponentially increases as the system scales up.
The DL-based logic reasoning technique is applied to service modeling and verification. Liu et al. [57] proposed a service modeling and composition method based on DL rules using a uniform way of characterizing the static semantic and dynamic interaction characteristics of web services. The method unifies the service composition model within the framework of DL rules to remedy the defect that DL cannot describe the dynamic characteristics of web services. Chang et al. [58, 59] proposed an Extended Dynamic Description Logic EDDL(X) by extending the traditional Dynamic Description Logic (DDL) to transform the web service composition model into the EDDL(X)-based one. However, the above methods focus more on service discovery, service matching, and service composition while addressing less the property verification of service choreography model.
Over the past decade, many organizations and individuals have conducted in-depth and fruitful research in the field of service choreography model verification. Their achievements can be categorized, according to their underlying methods, into hard-coding, simulation engine, workflow, temporal logic, and Abstract WS-CDL. As shown in Table 4, we have made a primary comparison of our method with those techniques by the important features such as description ability, degree of automation, knowledge reusability, efficiency of verification, and state explosion.
Regarding description ability, the methods of hardcoding and the simulation engine rank highest since they allow compiling the XML scripts of WS-CDL models. CMVDL ranks second high due to the strong ability of induction and high level of abstraction with DL [60]. The methods based on workflow and TL are weak in description ability, because they cannot ensure the completeness of mapping

18

Mathematical Problems in Engineering

one form of model to another, especially when the model is complex in its structure. The current methods based on PA, for example, provide only a few of simple mapping rules and thus do not guarantee a strict conversion, which may cause loss of semantics during conversion [61].
Automation is an important feature for model verification. Each of the methods listed has related supporting tools, except for Abstract WS-CDL. CMV-DL is graded comparatively high in automation, because it takes advantage of available reasoning engines such as Pellet which are based on the mature algorithm Tableau and which have been integrated into the requirement analysis tool OBREAT.
Regarding knowledge reusability, the workflow based, the TL based, and the other three techniques do not provide the mechanism for knowledge accumulation and reuse, while OBREAT allows enriching domain knowledge by adding new reasoning rules to the Domain Knowledge base and importing the reasoning results back into the knowledge base for further reasoning. But the process relies on human interference and thus the capability is graded low.
The verification efficiency is determined by both human interference and time consumption in validation process. The hard-code method and CMV-DL depend heavily on human interference and therefore are graded lowest. The simulation engine technique needs to traverse the entire value space when handling existential and universal quantifiers, which leads to a higher complexity and therefore a low efficiency. The other three methods, supported by automated tools, work highly efficiently for verification.
When a system has many concurrent components, the state space of system execution might expand infinitely beyond ordinary computation capability. Based on exhaustive search, workflow and TL may suffer from the problem of state explosion which has long been the bottleneck for their development [62]. In contrast, CMV-DL works on deduction reasoning where the space of deduction reasoning is limited by the size of the generated ontology and the computation complexity is decreased by the high efficient reasoner algorithm Tableau [63, 64].
In general, CMV-DL has an obvious advantage in knowledge reusability and is free of state explosion without the loss of description ability, and it has a modest degree of automation and efficiency compared to the other methods.
6. Conclusion and Future Work
This paper focuses on service choreography modeling and verification. It proposes a new approach of choreography model verification based on Description Logic to verify the service choreography model based on SHOIN(D) of DL. The main contributions are as follows:
(1) A metaconcept model of service choreography based on WS-CDL is proposed, providing a framework to formally define a service choreography model.
(2) Domain rules of consistency, completeness, and deductive reasoning are defined, enabling formal verification of the service choreography model.

(3) The model transformation algorithms are provided and thus the service choreography model and domain rules can be converted into the DL ontology and model verification can be thereby made automatically with an available reasoner, such as Pellet.
(4) The related work on service choreography verification is investigated. The representative methods are analytically compared with CMV-DL on such features as description ability, degree of automation, knowledge reusability, efficiency of verification, and state explosion.
Currently, CMV-DL focuses only on a few key issues of web service choreography. The goal of the metaconcept model and CMV-DL is to verify several key properties of service choreography models. Therefore, CMV-DL captures only a core set of WS-CDL features while omitting some advanced features, such as exception and finalizing blocks. Future work involves extending the service choreography metaconcept model to cover more properties of WS-CDL, such as the consistency between choreography models and orchestration models. Moreover, the domain rules need to be enriched and improved as the approach is applied to more projects.
Conflict of Interests
The authors declare that there is no conflict of interests regarding the publication of this paper.
Acknowledgment
The paper work was supported by National Natural Science Foundation of China under Program no. 61273210.
References
[1] R. Khadka, B. Sapkota, L. Ferreira Pires, M. Van Sinderen, and S. Jansen, â€œModel-driven approach to enterprise interoperability at the technical service level,â€ Computers in Industry, vol. 64, no. 8, pp. 951â€“965, 2013.
[2] Q. Z. Sheng, X. Qiao, A. V. Vasilakos, C. Szabo, S. Bourne, and X. Xu, â€œWeb services composition: a decadeâ€™s overview,â€ Information Sciences, vol. 280, pp. 218â€“238, 2014.
[3] N. Kavantzas, D. Burdett, G. Ritzinger et al., Web Services Choreography Description Language Version 1.0, W3C Candidate Recommendation, 2005.
[4] F.-X. Xiao, Z.-Q. Huang, Z.-N. Cao, L.-Z. Tu, and Y. Zhu, â€œUnified formal modeling and analyzing both functionality and qos of web services composition,â€ Journal of Software, vol. 22, no. 11, pp. 2698â€“2715, 2011.
[5] M. E. Cambronero, G. DÂ´Ä±az, V. Valero, and E. MartÂ´Ä±nez, â€œValidation and verification of web services choreographies by using timed automata,â€ Journal of Logic and Algebraic Programming, vol. 80, no. 1, pp. 25â€“49, 2011.
[6] L. Zhou, J. Ping, H. Xiao, Z. Wang, G. Pu, and Z. Ding, â€œAutomatically testing web services choreography with assertions,â€ in Formal Methods and Software Engineering, vol. 6447 of Lecture Notes in Computer Science, pp. 138â€“154, Springer, Berlin, Germany, 2010.

Mathematical Problems in Engineering

19

[7] F. M. Besson, P. M. B. Leal, F. Kon et al., â€œTowards automated testing of web service choreographies,â€ in Proceedings of the 6th International Workshop on Automation of Software Testing, pp. 109â€“110, 2011.
[8] X. Gu and Z. Lu, â€œA formal model for BPEL4WS description of Web service composition,â€ Wuhan University Journal of Natural Sciences, vol. 11, no. 5, pp. 1311â€“1319, 2006.
[9] X. Gu, R. Li, and Z. Lu, â€œTyped formal model for WS-CDL specification of web services composition,â€ Journal of Southeast University, vol. 24, no. 3, pp. 300â€“307, 2008.
[10] S. HalleÂ´ and T. Bultan, â€œRealizability analysis for message-based interactions using shared-state projections,â€ in Proceedings of the 18th ACM SIGSOFT International Symposium on the Foundations of Software Engineering, pp. 27â€“36, November 2010.
[11] A. McNeile, â€œProtocol contracts with application to choreographed multiparty collaborations,â€ Service Oriented Computing & Applications, vol. 4, no. 2, pp. 109â€“136, 2010.
[12] S. Basu, T. Bultan, and M. Ouederni, â€œDeciding choreography realizability,â€ Acm Sigplan Notices, vol. 47, no. 1, pp. 191â€“201, 2012.
[13] W. L. Yeung, â€œA formal and visual modeling approach to choreography based web services composition and conformance verification,â€ Expert Systems with Applications, vol. 38, no. 10, pp. 12772â€“12785, 2011.
[14] R. J. Brachman and J. G. Schmolze, â€œAn overview of the KL-ONE knowledge representation system,â€ Cognitive Science, vol. 9, no. 2, pp. 171â€“216, 1985.
[15] P. Cimiano, C. Uuger, and J. McCrae, Ontology-Based Interpretation of Natural Language, Morgan & Claypool Publishers, 2014.
[16] Web Ontology Language (OWL), World Wide Web Consortium (W3C), 2014, http://www.w3.org/2004/OWL.
[17] J. A. Khan and S. Kumar, â€œOWL, RDF, RDFS inference derivation using Jena semantic framework & pellet reasoner,â€ in Proceedings of the International Conference on Advances in Engineering and Technology Research (ICAETR â€™14), pp. 1â€“8, IEEE, Unnao, India, August 2014.
[18] D. RodrÂ´Ä±guez, E. GarcÂ´Ä±a, S. SaÂ´nchez, and C. R.-S. Nuzzi, â€œDefining software process model constraints with rules using OWL and SWRL,â€ International Journal of Software Engineering and Knowledge Engineering, vol. 20, no. 4, pp. 533â€“548, 2010.
[19] Object Management Group (OMG), Meta Object Facility (MOF) Core Specification Version 2.0, 2006, http://www.omg .org/spec/MOF/2.0/PDF.
[20] Q. Dong, Z. Wang, W. Zhu, and H. He, â€œCapability requirements modeling and verification based on fuzzy ontology,â€ Journal of Systems Engineering and Electronics, vol. 23, no. 1, pp. 78â€“87, 2012.
[21] A. Queralt, G. Rull, E. Teniente, C. FarreÂ´, and T. UrpÂ´Ä±, â€œAuRUS: automated reasoning on UML/OCL schemas,â€ in Conceptual Modelingâ€”ER 2010, vol. 6412 of Lecture Notes in Computer Science, pp. 438â€“444, Springer, Berlin, Germany, 2010.
[22] Q.-C. Dong, Z.-X. Wang, G.-Y. Chen, J. Xin, and T.-T. Zhang, â€œDomain-specific modeling and verification for C4ISR capability requirements,â€ Journal of Central South University of Technology, vol. 19, no. 5, pp. 1334â€“1340, 2012.
[23] Q. Dong, Research on formal analysis framework of effectiveness concept of C4ISR systems [Ph.D. thesis], PLA University of Science and Technology, 2013.
[24] H. He, Z. Wang, Q. Dong, W. Zhang, and W. Zhu, â€œOntologybased semantic verification for UML behavioral models,â€ International Journal of Software Engineering and Knowledge Engineering, vol. 23, no. 2, pp. 117â€“145, 2013.

[25] Y. Zhang, Research on key techniques for service-oriented C4ISR capability requirements analysis, modeling and design [Ph.D. thesis], PLA University of Science and Technology, 2012.
[26] T. Bultan and X. Fu, â€œSpecification of realizable service conversations using collaboration diagrams,â€ Service Oriented Computing & Applications, vol. 2, no. 1, pp. 27â€“39, 2008.
[27] J. Su, T. Bultan, X. Fu, and X. Zhao, â€œTowards a theory of web service choreographies,â€ in Web Services and Formal Methods: 4th International Workshop, WS-FM 2007, Brisbane, Australia, September 28-29, 2007. Proceedings, vol. 4937 of Lecture Notes in Computer Science, pp. 1â€“16, Springer, Berlin, Germany, 2008.
[28] T. Bultan and X. Fu, â€œChoreography modeling and analysis with collaboration diagrams,â€ Bulletin of the Technical Committee on Data Engineering, no. 3, 2008.
[29] I. Yahmadi, Y. Baghdadi, and Z. Al-Khanjari, â€œGraphical description of WS-CDL,â€ in Proceedings of the 9th International Conference on Innovations in Information Technology (IIT â€™13), vol. 4, pp. 192â€“197, March 2013.
[30] M. Emilia Cambronero, V. Valero, and E. MartÂ´Ä±nez, â€œDesign and generation of Web services choreographies with time constraints,â€ Journal of Universal Computer Science, vol. 17, no. 13, pp. 1800â€“1829, 2011.
[31] A. Mellat, N. Nematbakhsh, A. Farahi, and F. Mardukhi, â€œSuitability of uml state machine for modeling choreography of services,â€ International Journal of Web & Semantic Technology, vol. 2, no. 4, pp. 33â€“53, 2011.
[32] H. Foster, S. Uchitel, J. Magee, and J. Kramer, â€œAn integrated workbench for model-based engineering of service compositions,â€ IEEE Transactions on Services Computing, vol. 3, no. 2, pp. 131â€“144, 2010.
[33] M. V. Rosing, S. White, F. Cummins et al., â€œBusiness process model and notationâ€”BPMN,â€ in Business Process Management Handbook, pp. 429â€“453, 2015.
[34] M. Cortes-Cornax, S. Dupuy-Chessa, D. Rieu, and N. Mandran, â€œEvaluating the appropriateness of the BPMN 2.0 standard for modeling service choreographies: using an extended quality framework,â€ Software & Systems Modeling, 2014.
[35] OMG, OMG Unified Modeling Language (OMG UML), Superstructure, V.2.1.2, 2007, http://www.omg.org/spec/UML/2.1.2/ Infrastructure/PDF.
[36] D. Li, X. Li, and V. Stolz, â€œQVT-based model transformation using XSLT,â€ Acm Sigsoft Software Engineering Notes, vol. 36, no. 1, pp. 1â€“8, 2011.
[37] A. Belghiat and M. Bourahla, â€œTransformation of UML models towards OWL ontologies,â€ in Proceedings of the 6th International Conference on Sciences of Electronics, Technologies of Information and Telecommunications (SETIT â€™12), pp. 840â€“846, March 2012.
[38] No Magic, MagicDraw Technical Overview, 2015, http://www .nomagic.com/products/magicdraw.html.
[39] J. Su and Y. Sun, â€œChoreography revisited,â€ in Web Services and Formal Methods, vol. 8379 of Lecture Notes in Computer Science, pp. 13â€“25, Springer, 2014.
[40] S. Wieczorek, Modeling and Model-Based Testing of Service Choreographies, Akademische Verlagsgemeinschaft MuÂ¨nchen, 2011.
[41] A. Barros, T. Hettel, and C. Flender, â€œProcess choreography modeling,â€ in Handbook on Business Process Management 1, International Handbooks on Information Systems, pp. 257â€“277, Springer, Berlin, Germany, 2010.

20

Mathematical Problems in Engineering

[42] V. Haarslev and R. MoÂ¨ller, â€œConsistency testing: the race experience,â€ in Automated Reasoning with Analytic Tableaux and Related Methods, vol. 1847 of Lecture Notes in Computer Science, pp. 57â€“61, Springer, Berlin, Germany, 2000.
[43] B. Motik and U. Sattler, â€œA comparison of reasoning techniques for querying large description logic Aboxes,â€ in Logic for Programming, Artificial Intelligence, and Reasoning: 13th International Conference, LPAR 2006, Phnom Penh, Cambodia, November 13â€“17, 2006. Proceedings, vol. 4246 of Lecture Notes in Computer Science, pp. 227â€“241, Springer, Berlin, Germany, 2006.
[44] P. Cimiano, P. Haase, Q. Ji et al., â€œReasoning with large a-boxes in fuzzy description logics using dl reasoners: an experimental evaluation,â€ in Proceedings of the ESWC Workshop on Advancing Reasoning on the Web Scalability & Commonsense, 2008.
[45] Z. Wang, L. Zhou, Y. Zhao et al., â€œWeb services choreography validation,â€ Service Oriented Computing and Applications, vol. 4, no. 4, pp. 291â€“305, 2010.
[46] WS-CDL Eclipse Plugin, 2014, http://wscdl-eclipse.sourceforge .net.
[47] C. Das and P. Bhuyan, â€œA systematic survey report on various frameworks and models for verification of choreography in SOA,â€ Journal of Computer Science & Engineering Technology, vol. 5, no. 4, pp. 411â€“418, 2014.
[48] F. Besson, A framework for automated testing of web service choreographies [Ph.D. thesis], University of SaËœo Paulo, SaËœo Paulo, Brazil, 2011.
[49] Y. Xia, H. Xue, and X. Wang, â€œPerformance prediction of WSCDL based service composition,â€ in Proceedings of the 10th International Conference on Quality Software (QSIC â€™10), pp. 294â€“299, July 2010.
[50] Y. Dong, Y. Xia, T. Sun, and Q. Zhu, â€œModeling and performance evaluation of service choreography based on stochastic Petri net,â€ Journal of Computers, vol. 5, no. 4, pp. 516â€“523, 2010.
[51] H. Foster, S. Uchitel, J. Magee, and J. Kramer, â€œAn integrated workbench for model-based engineering of service compositions,â€ IEEE Transactions on Services Computing, vol. 3, no. 2, pp. 131â€“144, 2010.
[52] C. Molina-Jimenez and S. Shrivastava, â€œEstablishing conformance between contracts and choreographies,â€ in Proceedings of the 15th IEEE Conference on Business Informatics (CBI â€™13), pp. 69â€“78, IEEE, Vienna, Austria, July 2013.
[53] G. DÂ´Ä±az and L. Llana, â€œContract compliance monitoring of web services,â€ in Service-Oriented and Cloud Computing, vol. 8135 of Lecture Notes in Computer Science, pp. 119â€“133, Springer, Berlin, Germany, 2013.
[54] P. Nduwimfura, D. Xu, H. Miao, Z. Lei, and B. Chen, â€œReasoning on formalizing WS-CDL mobility using process algebra,â€ in Proceedings of the IEEE Asia-Pacific Services Computing Conference (APSCC â€™10), pp. 676â€“682, December 2010.
[55] G. SalauÂ¨n, T. Bultan, and N. Roohi, â€œRealizability of choreographies using process algebra encodings,â€ IEEE Transactions on Services Computing, vol. 5, no. 3, pp. 290â€“304, 2012.
[56] X. Zhang and H. Liu, â€œFormal verification for CCML based web service composition,â€ Information Technology Journal, vol. 10, no. 9, pp. 1692â€“1700, 2011.
[57] S. Liu, D. Liu, H. Qi, and J. Guan, â€œComposing semantic web service with description logic rules,â€ Journal of Computer Research and Development, vol. 48, no. 5, pp. 831â€“840, 2011.
[58] L. Chang, Z. Z. Shi, L. M. Chen, and W. Niu, â€œFamily of extended dynamic description logics,â€ Journal of Software, vol. 21, no. 1, pp. 1â€“13, 2010.

[59] L.Chang,Z.Shi,T.Gu,and L. Zhao, â€œA family of dynamic description logics for representing and reasoning about actions,â€ Journal of Automated Reasoning, vol. 49, no. 1, pp. 1â€“52, 2012.
[60] B. B. Hariri, D. Calvanese, M. Montali, G. de Giacomo, R. De Masellis, and P. Felli, â€œDescription logic knowledge and action bases,â€ Journal of Artificial Intelligence Research, vol. 46, pp. 651â€“ 686, 2013.
[61] Z. Huang, F. Xiao, and L. Tu, â€œModeling service composition using priced probabilistic process algebra,â€ in Proceedings of the 5th IEEE International Symposium on Service-Oriented System Engineering (SOSE â€™10), pp. 35â€“38, June 2010.
[62] P. Drobintsev, V. P. Kotlyarov, and I. V. Nikiforov, â€œTechnology aspects of state explosion problem resolving for industrial software design,â€ in Proceedings of the Spring/Summer Young Researchersâ€™ Colloquium on Software Engineering, pp. 46â€“51, Kazan, Russia, May 2013.
[63] S. Ben-David, R. Trefler, and G. Weddell, â€œModel checking using description logic,â€ Journal of Logic & Computation, vol. 20, no. 1, pp. 111â€“131, 2010.
[64] E. M. Clarke, W. Klieber, M. NovaÂ´cË‡ek, and P. Zuliani, â€œModel checking and the state explosion problem,â€ in Tools for Practical Software Verification, vol. 7682 of Lecture Notes in Computer Science, pp. 1â€“30, Springer, Berlin, Germany, 2012.

Advances in
Operations Research

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Advances in
Decision Sciences

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Applied Mathematics

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Algebra
Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Probability and Statistics

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

The Scientific World Journal

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

International Journal of
Combinatorics

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Submit your manuscripts at http://www.hindawi.com

International Journal of
Differential Equations

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Advances in
Mathematical Physics

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Complex Analysis

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Mathematics
Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Mathematical Problems in Engineering

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Abstract and Applied Analysis
Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Discrete Dynamics in Nature and Society

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

International Journal of Mathematics and Mathematical Sciences

Journal of
Discrete Mathematics

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Function Spaces

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

International Journal of
Stochastic Analysis

Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

Journal of
Optimization
Hindawi Publishing Corporation http://www.hindawi.com

Volume 2014

