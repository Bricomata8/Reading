2017 IEEE 14th International Conference on Services Computing

Towards a Framework for Detecting Containment Violations in Service Choreography
Faiz UL Muram, Muhammad Atif Javed, Huy Tran and Uwe Zdun University of Vienna, Faculty of Computer Science,
Software Architecture Research Group, Vienna, Austria Email: faiz.ulmuram|muhammad.atif.javed|huy.tran|uwe.zdun@univie.ac.at

Abstract‚ÄîIn the design and development of service oriented applications, service choreography models describe the interactions between services at different abstraction levels. These models are usually created and evolved independently by different stakeholders and consequently deviations occur among models such as message not received and incompatible behaviours. It is therefore crucial to detect and resolve the deviations before actual implementation and deployment is undertaken. This paper presents a containment checking approach that veriÔ¨Åes whether the behaviour (or interactions) described by the local choreography models collectively encompasses those speciÔ¨Åed in the global model. Previous studies have not considered the containment relationship between global and local choreography models. The proposed approach performs automated transformation of service choreography models into formal descriptions and consistency constraints for leveraging the analytical powers of model checking techniques for the containment veriÔ¨Åcation. The approach provides more informative and comprehensive feedbacks to the stakeholders for identiÔ¨Åcation of containment problems and their resolutions. The applicability of the approach is demonstrated through use case scenarios of ATM machine, travel booking and order processing systems.
Keywords-containment checking; choreography; web services; business process modelling; formal methods.
I. INTRODUCTION
In choreography-based service-oriented systems, a typical design and development scenario is that the global model (aka interaction model) is created by business analysts to agree on interaction scenarios from a global perspective. The global model will then be reÔ¨Åned during detailed design phase into the public visible behaviour and hence forms a local choreography model (aka interconnection model) of each participant. The local choreography model shows an abstraction of orchestration internal actions/activities. The local choreography models often deviate from the global model due to the involvement of different stakeholders and independent evolutions. Hence, detecting model inconsistencies in early phases of the service development life cycle is crucial to eliminate as many anomalies as possible before service-oriented systems are actually implemented and deployed.
The literature discusses two possible ways to alleviate such problems: (i) the local models (i.e., representing implementation of individual services) can be generated from the global model [1]; (ii) the global and orchestration models can be created separately and then checked against each other [2]. The former strategy, although helpful to certain extent, did not prevent the overriding of manual changes that are made

to complete the models. The later strategy focuses on the assessment of model inconsistencies that require formal descriptions and consistency constraints of the models. However, it is a challenging task to accurately and correctly express such formal descriptions and consistency constraints due to the substantial amount of knowledge and specialized training required for the underlying formalisms and formal techniques. In addition, the produced results are rather cryptic and verbose; they are difÔ¨Åcult to interpret and understand for software architects/developers who often have limited knowledge of the underlying formal techniques [3].
In this paper, we proposed a containment checking approach that veriÔ¨Åes whether the behaviour (or interactions) described in the local choreography models collectively encompasses those speciÔ¨Åed in the global model. This improves the quality and correctness of the service oriented systems. To date, however, previous studies have not considered the containment relationship between global and local choreography models. SpeciÔ¨Åcally, we have performed automated translation of global choreography model into consistency constraints i.e., linear temporal logic (LTL) [4] and local choreography models into formal descriptions i.e., SMV language (symbolic model veriÔ¨Åer); whereas the NuSMV (new symbolic model veriÔ¨Åer) model checker [5] is used that supports the veriÔ¨Åcation of large systems up to 1020 states. This way, our approach helps to alleviate the burden of manually encoding consistency constraints, and therefore, increase productivity and avoid potential translation errors. In order to facilitate better feedback, we integrate the counterexample analysis method for locating the cause(s) of containment violations and presenting the appropriate suggestions to stakeholders for their resolutions. Moreover, we investigated the performance of the proposed approach on use case scenarios of ATM machine, travel booking and order processing systems. This is done to ensure whether the stakeholders are supported to verify the containment relationship during their development tasks.
The rest of this paper is organized as follows: Section II motivates the necessity of containment checking in service choreographies and explains a running example modelled using business process model and notation (BPMN) diagrams. Section III describes a novel approach for assessment of containment violations in service choreographies and recommendations for their resolutions. Section IV describes the performance evaluation of the proposed approach. Section V

2474-2473/17 $31.00 ¬© 2017 IEEE

172

DOI 10.1109/SCC.2017.29

presents the related work. Section VI concludes the paper.

II. MOTIVATION AND RUNNING EXAMPLE

Service choreography is a set of interrelated service interactions at the high-level of abstraction, which represents message exchanges, interaction rules and agreements between web service partners. Figure 1 shows a global model of the Travel Booking application modelled using the BPMN 2.0 choreography notation [6]. The sender and receiver of a message are collapsed into one choreography activity; the unshaded and gray shaded bands represent the sender (initiating participant) and the receiver (non-initiating participant) of a message, respectively. The collaboration in travel booking choreography process involves six partners/participants, namely traveller, travel agency, acquirer, airline, hotel and rent a car agencies.

7UDYHO $JHQF\

7UDYHOOHU %RRNLQJ 5HTXHVW 7UDYHO $JHQF\

1RW $YDLODEOH 7UDYHOOHU
1R

7UDYHOOHU &UHGLW 'HWDLOV 7UDYHO $JHQF\

&KHFN DYDLODELOLW\"

<HV

$FTXLUHU )DLOXUH 7UDYHO $JHQF\

7UDYHO $JHQF\ 8QDXWKRUL]HG &UHGLW &DUG
7UDYHOOHU

7UDYHO $JHQF\ %RRN )OLJKW $LUOLQH

$LUOLQH
3XUFKDVH &RQILUPDWLRQ

7UDYHO $JHQF\
7UDYHO ,WLQHUDU\ 7UDYHOOHU

7UDYHO $JHQF\ %RRNLQJ 6WDWXV
7UDYHOOHU
7UDYHOOHU $FFHSW 2IIHU 7UDYHO $JHQF\

$FTXLUHU $SSURYHG 7UDYHO $JHQF\

1R

<HV

,V FDUG YDOLG"

7UDYHO $JHQF\

$LUOLQH H7LFNHW 7UDYHO $JHQF\

7UDYHO $JHQF\ 5HVHUYH 5RRP
+RWHO

+RWHO
&RQILUP 5HVHUYDWLRQ
7UDYHO $JHQF\

7UDYHO $JHQF\ $XWKRUL]H &UHGLW &DUG
$FTXLUHU

7UDYHO $JHQF\ 5HQWDO 5HTXHVW
5HQW D &DU

5HQW D &DU 9HKLFOH $VVLJQ 7UDYHO $JHQF\

Fig. 1: Travel Booking System: Global Choreography Model

The local choreography models of all participants (i.e., pools) involved in the travel booking system are shown in Figure 2. The message Ô¨Çow indicates the exchange of a message between two participants; whereas the sequence Ô¨Çow reÔ¨Çects the order in which activities are performed within a pool. It is crucial to sequence the choreography activities in such a way that the participants involved in the service choreography know when they are responsible for initiating the interactions. For instance, the BookingRequest and CreditDetails messages in the global model meant to be received in a sequential order (i.e., CreditDetails message follows BookingRequest message), as shown in Figure 1. However, the local model of the travel agency participant shown in Figure 2 speciÔ¨Åes that the CreditDetails message precedes BookingRequest message. Furthermore, the sequential order of PurchaseConfirmation and e-Ticket messages is replaced by the parallel order using fork and join in the local choreography models, in particularly travel agency and airline. Please note that the containment checking not only deals with the missing participant or interaction

7U DYHO OHU

%RRNLQJ 5HTXHVW &UHGLW 'HWDLOV

1RW $YDLODEOH

%RRNLQJ 6WDWXV $FFHSW 2IIHU

7UDYHO ,WLQHUDU\ 8QDXWKRUL]HG &UHGLW &DUG

7UDYHO $JHQF\

&UHGLW 'HWDLOV 1RW $YDLODEOH $XWKRUL]H &UHGLW &DUG

)DLOXUH 8QDXWKRUL]HG &UHGLW &DUG

1R %RRNLQJ 5HTXHVW
&KHFN DYDLODELOLW\" <HV %RRNLQJ 6WDWXV
$FFHSW 2IIHU

$SSURYHG %RRN )OLJKW 5HVHUYH 5RRP 5HQWDO 5HTXHVW

7UDYHO ,WLQHUDU\ 3XUFKDVH &RQILUPDWLRQ
H7LFNHW
&RQILUP 5HVHUYDWLRQ

9HKLFOH $VVLJQ

+RWHO

5HVHUYH 5RRP &RQILUP 5HVHUYDWLRQ

$ FTX L UHU

$SSURYHG <HV

$XWKRUL]H &UHGLW &DUG

1R

,V FDUG YDOLG"

)DLOXUH

5HQW D &DU

5HQWDO 5HTXHVW 9HKLFOH $VVLJQ

$ LU OL Q H

%RRN )OLJKW

3XUFKDVH &RQILUPDWLRQ H7LFNHW

Fig. 2: Travel Booking System: Local Choreography Models

but also misplacement of elements among the models. The undesired containment violations would cause severe problems; for example, improper identiÔ¨Åcation of services and their corresponding service providers, and therefore affect the delivery of services. In order to eliminate such problems, containment checking shall be performed.
III. APPROACH
In this section, we address the problem of checking whether the message exchange behaviour (or interactions) described in the joint local choreography models encompasses those speciÔ¨Åed in the global model. Formally, the containment relationship between service choreographies is deÔ¨Åned in such a way that (GCM ‚Üí LT L) ‚â∫ (LCMi = (LCM1...LCMn) ‚Üí SMV ), where GCM denotes the global choreography model that is mapped to LTL formulas and LCMi denotes a joint set of local choreography models that is mapped to SMV descriptions. An overview of our approach is shown in Figure 3. In the following sections, we describe each step of our approach.

EXVLQHVV DQDO\VW  VRIWZDUH DUFKLWHFW

*OREDO &KRUHRJUDSK\
0RGHO
/RFDO &KRUHRJUDSK\
0RGHOV

7UDQVIRUPDWLRQ RI *OREDO 0RGHO
7UDQVIRUPDWLRQ RI /RFDO 0RGHOV

/7/ )RUPXODV
609 'HVFULSWLRQV

1X609 0RGHO &KHFNLQJ

GHVLJQHU  GHYHORSHU

&RXQWHUH[DPSOH $QDO\VLV

&RQWDLQPHQW 5HVXOWV

Fig. 3: Overview of the Containment Checking Approach

173

A. Generating LTL Constraints from GCM The section is concerned with the automated transformation
of global choreography model (GCM) into formal consistency constraints. From the containment checking perspective, the control Ô¨Çow relations between choreographic activities or interactions need to be represented in an appropriate formalism so that the execution order of interactions will become the consistency constraints for all local choreography models. In this context, a certain execution path is derived from the global model for describing the temporal relationships among the elements (e.g., choreography tasks, senders and receivers of the interactions, and guard conditions) using LTL [4]. The behavioural properties of the model can be easily expressed in LTL. It is widely-used in formal veriÔ¨Åcation tools [7].
LTL extends the classical propositional logic (¬¨, ‚àß, ‚à®, ‚Üí) with several future temporal operators such as F (‚ÄúFinally‚Äù), X (‚ÄúneXt‚Äù), G (‚ÄúGlobally‚Äù) and U (‚ÄúUntil‚Äù), and past temporal operators such as H (‚ÄúHistorically‚Äù), O (‚ÄúOnce‚Äù) and Y (‚ÄúYesterday‚Äù). This research focuses on both future and past temporal operators. The exclusive decision and merge gateways are implemented as ‚Äú(a ‚àß ¬¨b) ‚à® (¬¨a ‚àß b)‚Äù instead of using logical ‚Äúxor‚Äù operator. This is because, xor operator yields true not only when one of its operands is true but also when the odd numbers (i.e., n ‚â• 3) of the operands are true [8]. The generated formulas for different path constructs i.e., fork and join are enclosed by the G and H operators to express that all possible execution scenarios of the formulas are satisÔ¨Åed.

Algorithm 1 Translate GCM into LTL Formulas

1: procedure TRANSLATE(GCM)

2: Q ‚Üê ‚àÖ

Q is the queue of non-visited interactions

3: V ‚Üê ‚àÖ

V is the queue of visited interactions

4: Q ‚Üê Q ‚à™ get_start_events(e)

5: for all i ‚àà Q do

6:

V ‚Üê V ‚à™ {i}

7:

Q ‚Üê Q \ {i}

8:

generate_ltl_code(i)

9:

Isucceding_interactions ‚Üê get_interaction(i)

10:

for all j ‚àà Isucceding_interactions do

11:

if ( j ‚àà V ) then

12:

Q ‚Üê Q ‚à™ { j}

13: extracts interaction information;

14: binds input values and generates ltl formu-

las using the following templates:

15: for all (i ‚â• 0) ‚àß V ‚Üê V ‚à™ {i} do

16:

if i ‚àà AND ‚àí Join ‚àß i ‚àà Ipreceding_interactions_rec then

17:

'''

18:

(LTLSPEC G(¬´i¬ª & ¬´i¬ª -> F ¬´ j¬ª) & H(¬´ j¬ª

-> O ¬´i¬ª & ¬´i¬ª))

19:

'''

The construction of LTL formulas for containment checking is a highly knowledge intensive endeavour. In this context, the LTL-based transformation rules are deÔ¨Åned to formally represent the constructs of GCM. Therefore, the input GCM is automatically translated into corresponding LTL formulas using the LTL-based transformation rules. In our formalisation, we map a choreography interaction as a 3-tuple participant_name,

msg, snd/rec ; where (i) participant_name indicates the corresponding participant; (ii) msg represents a message that describes communication contents between two participants; and (iii) snd and rec describe the sending and receiving actions of the corresponding message, respectively. However, the initiating participants of the choreography activities must have been involved in the previous activity (excluding Ô¨Årst activity).
The Eclipse Xtend1 framework is leveraged to translate the GCM into LTL formulas. SpeciÔ¨Åcally, the breadthÔ¨Årst search algorithm is extended with three helper functions, namely get_events(e), get_interaction(i) and generate_ltl_code(i), as shown in Algorithm 1. The function get_events(e) returns a set of start events. A start event indicates the starting point of a choreography. Hence, it has no incoming sequence Ô¨Çow. The function get_interaction(i) extract all interactions i. The choreography tasks along with the senders and receivers of the messages, as well as the message exchange dependencies (i.e., sequence Ô¨Çows or gateways) are extracted. An interaction j is called ‚Äúsucceeding interaction‚Äù of i if there is a control Ô¨Çow going from i to j. Thus, a set of succeeding choreography activities of i can be achieved by following all of its outgoing control Ô¨Çows.
The generate_ltl_code(i) function is responsible for generating LTL formulas for each construct of a GCM. The pair of triple apostrophes (''') represents the string templates that are used for code generation based on Eclipse Xtend framework. However, a pair of guillemots (¬´ and ¬ª) is used to represent the parametrised place-holders that will be bound to and substituted with the actual values extracted from the input model elements by the Xtend engine. The generate_ltl_code(i) function is not realized as a single function but rather a polymorphism of multiple functions. That is, depending on the type of the input interaction i, a particular function for generating LTL formulas for that interaction will be invoked. The LTL-based transformation rules for Parallel Join is presented in Algorithm 1. In particular, LTL formula for Parallel Join requires visited predecessors that are joined using the logical AND operator (‚Äú&‚Äù) and offered to Parallel Join. The Parallel Join cannot execute until all incoming Ô¨Çows have been received. Table I summarises the constructs of choreography models along with their informal descriptions extracted from the BPMN 2.0 speciÔ¨Åcation [6] and LTL-based transformation rules that constitutes the interactions between participants.
B. Generating SMV Descriptions from LCMi This section concerns the generation of formal SMV de-
scriptions from the local choreography models (LCMi). To deÔ¨Åne the interactions within a BPMN 2.0 collaboration diagram, 2-tuple participant_name,task_snd/task_rec is used to represent the participant name and send task/receive task. The mapping of (LCMi) into SMV descriptions is attained using an extended version of the breadth-Ô¨Årst search, as shown in Algorithm 2. Similar to GCM, three helper functions
1See https://eclipse.org/xtend

174

TABLE I: LTL-Based Transformation Rules for BPMN Global Choreography Model

BPMN Choreography
Sequence: (i) The sending action of a choreography task must exist before its receiving action. (ii) The initiator of a choreography task (excluding Ô¨Årst activity) can not send a message to the receiver until it has received the prior message. Parallel Fork: The execution of a Parallel Fork (AND-Split) leads to the parallel execution of subsequent choreography tasks. The initiators of all choreography tasks immediately following the Parallel Fork must be same as the common sender or receiver of choreography tasks preceding the gateway. Parallel Join: The concurrent execution of multiple interactions lead to the execution of a Parallel Join (AND-Join) gateway. However, all incoming branches have to be completed before the execution of a Parallel Join.
Exclusive Decision: The execution of an Exclusive Decision (XOR-Split) is spawn in two or more branches, which branch is actually traversed depends on the evaluation of the guards on the outgoing Ô¨Çows.
Exclusive Merge: The execution of one of the choreography receiving action among a set of alternative receiving actions will lead to the execution of an Exclusive Merge (XOR-Join).
Inclusive Decision: An Inclusive Decision gateway (OR-Split) represents the execution of one or more alternative branches. The traversal of branches depend on the evaluation of the guard conditions. In particular, all sequence Ô¨Çows with a true evaluation will be traversed.
Inclusive Merge: The alternative but also parallel execution of two or more active interactions lead to the execution of the Inclusive Merge gateway (ORJoin).
Event-Based: The execution of an Event-based gateway is spawn in two or more branches, which branch is actually traversed depends on a speciÔ¨Åc Event that occur. Usually, the receipt of a message or timeout determines the path that will be taken rather than the evaluation of the guards.

Modelling Notation

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW &

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW & 7DVN
3DUWLFLSDQW %

'HFLVLRQ "

<HV

1R

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW $

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW &

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

'HFLVLRQ"

&RQGLWLRQ

&RQGLWLRQ

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW &

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW &

3DUWLFLSDQW $ 7DVN
3DUWLFLSDQW %

3DUWLFLSDQW & 7DVN
3DUWLFLSDQW %

'HFLVLRQ"

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW $

3DUWLFLSDQW % 7DVN
3DUWLFLSDQW $

LTL-Based Transformation Rules
1)G (ParticipantA_Task1_Snd -> F (ParticipantB_ Task1_Rec))& H (ParticipantB_Task1_Rec -> O (
ParticipantA_Task1_Snd)) 2)F (ParticipantB_Task2_Snd)-> (! ParticipantB_
Task2_Snd U (ParticipantB_Task1_Rec))
G (Fork -> F (ParticipantA_Task1_Snd & ParticipantA_Task2_Snd))& H ((ParticipantA _Task1_Snd & ParticipantA_Task2_Snd)-> O Fork)
G ((ParticipantB_Task1_Rec & ParticipantB_Task2 _Rec)-> F Join)& H ((Join)-> O (ParticipantB
_Task1_Rec & ParticipantB_Task2_Rec))
(ExclusiveDecision -> F ((ParticipantB_Task2 _Snd & ! ParticipantB_Task3_Snd)| (! Particip antB_Task2_Snd & ParticipantB_Task3_Snd)))
(G (ParticipantB_Task1_Rec & ! ParticipantB _Task2_Rec)| (! ParticipantB_Task1_Rec &
ParticipantB_Task2_Rec)-> F ExclusiveMerge)
G ((InclusiveDecision & Condition1)-> F ( ParticipantB_Task1_Snd))| G ((InclusiveDecision
& Condition2)-> F (ParticipantB_Task2_Snd))
(G (ParticipantB_Task1_Rec | ParticipantB_Task2 _Rec)-> F InclusiveMerge)
G (Event-basedgateway & rec_msg1) -> F (ParticipantB_Task1_Snd & (! ParticipantB_Task2_Snd))| G (Event-basedgateway
& rec_msg2)-> F ((! ParticipantB_Task1_Snd)& ParticipantB_Task2_Snd)

are created, namely get_events(el), get_interaction(i) and generate_smv_code(i). The function get_events(el) returns a set of start events concerning the input LCMi. The function get_interaction(i) extracts all interactions such as choreography tasks, control nodes and connecting edges. In particular, given a certain interaction i, the outgoing interactions (within pool) can be attained using the function get_interaction(i). An interaction j is called ‚Äúoutgoing interaction‚Äù of i if there is a sequence Ô¨Çow going from i to j. In a similar way, communication between two participants (pools) can be achieved. An interaction j is called ‚Äúreceiving interaction‚Äù of i if there is a message Ô¨Çow going from i to j. Thus, a set of receiving actions of choreography tasks and outgoing interactions of i can be achieved by following all of its message Ô¨Çows and outgoing sequence Ô¨Çows, respectively.
The function generate_smv_code(i) is responsible for

generating the SMV description for each interaction within the LCMi. In particular, the aforementioned 2-tuple, control node or event will be represented by a boolean state variable in the section VAR and its corresponding state transitions will be described in the section ASSIGN by a combination of two functions given in NuSMV. The init() is used for assigning the initial state of a variable and next() is used for deÔ¨Åning the transition to the next state. The function next() is often combined with the branching structure ‚Äúcase/esac‚Äù for selecting one of many possible choices. The state is initially set to false. However, if the incoming condition(s) are satisÔ¨Åed, it is changed to a true state (see Line 22 in Algorithm 2). The incoming condition(s) would be a guard expression and/or Ô¨Ånishing of the preceding interaction(s). The interaction‚Äôs state shall be switched back to false after Ô¨Ånishing the execution (see Line 23 in Algorithm 2). Note

175

Algorithm 2 Generating SMV Descriptions from LCMi

1: procedure TRANSLATE(LCMi)

2: Q ‚Üê ‚àÖ

Q is the queue of non-visited interactions

3: V ‚Üê ‚àÖ

V is the queue of visited interactions

4: Q ‚Üê Q ‚à™ get_start_events(el)

5: for all i ‚àà Q do

6:

V ‚Üê V ‚à™ {i}

7:

Q ‚Üê Q \ {i}

8:

generate_smv_code(i)

9:

Ioutgoing_interactions ‚Üê get_interaction(i)

10:

Ireceiving_interactions ‚Üê get_interaction(i)

11:

for all j ‚àà Isucceding_interactions| j ‚àà Ireceiving_interactions do

12:

if ( j ‚àà V ) then

13:

Q ‚Üê Q ‚à™ { j}

14: extracts interaction information;

15: binds input values and generates SMV descrip-

tions using the following templates:

16:

17: VAR

18:

¬´i¬ª : boolean;

State variable declaration

19: ASSIGN

20:

init(¬´i¬ª) := ¬´interaction-initial-state¬ª

21:

next(¬´i¬ª) := case

22:

¬´incoming-condition(s)¬ª : TRUE;

23:

¬´i¬ª : FALSE;

24:

esac;

25:

that the generate_smv_code(i) is not realised as a single function but rather a polymorphism of multiple functions. That is, depending on the type of the input interaction i, a particular function for generating SMV descriptions for that node type will be invoked. The subsequent sections discuss the rules for generating SMV descriptions for each node type that constitutes the individual function generate_smv_code(i).
1) Task, Fork, Join, End Event and Start Event: This section focuses on a set of elements that are triggered with respect to their incoming Ô¨Çows and are formalised rather similar in SMV. Listing 1 illustrates the translation of Task, Fork, Join and End Event into SMV descriptions based on the translation template shown in Algorithm 2. If an interaction has multiple incoming Ô¨Çows, the logical AND operator (‚Äú&‚Äù) is used to represent the implicit ‚Äúand-join‚Äù guard for all tokens passing through the incoming Ô¨Çows. Note that none Start Event is a special event that denotes the starting point of a BPMN model. It does not have any incoming Ô¨Çows. Thus, each none Start Event is represented by a boolean state variable whose initial state would be assigned as true.

1 VAR

2 ¬´interaction¬ª : boolean;

3 ASSIGN

4 init(¬´interaction¬ª) := FALSE;

5 next(¬´interaction¬ª) := case

6

¬´incoming_1¬ª & ¬´incoming_2¬ª & ... & ¬´incoming_n¬ª : TRUE;

7

¬´interaction¬ª : FALSE;

8 esac;

Listing 1: Generic Rules for Generation SMV Descriptions

2) Branching: The Exclusive Decision, Inclusive Decision, and Event-based gateways are the branching constructs in BPMN speciÔ¨Åcation [6]. The execution of the

Exclusive Decision will trigger one of the outgoing Ô¨Çows according to the corresponding guard conditions. The initiating participant of the messages that follow the gateway controls the decision. Figure 4 shows the rules for mapping an Exclusive Decision into SMV descriptions whose guard conditions is abstracted as boolean variables (Line 7). We introduce a temporary variable named post_decision_i in which i is an incrementally generated number for exclusively choosing one of many alternative sequence Ô¨Çows. The variable post_decision_i has an enumerated type which includes a normal state ‚Äúundetermined‚Äù and the values corresponding to the sequence Ô¨Çows (Line 9). The choice among alternative sequence Ô¨Çows is made using a ‚Äúcase/esac‚Äù construct (Line 16‚Äì20). In case none of the guard conditions is true, the state transitions deÔ¨Åned in Figure 4 will be stuck. This is precise, but undesired behaviour. To avoid this stuck a ‚ÄúDefault Condition‚Äù for one of the outgoing sequence Ô¨Çows can be used. The default condition is a complement of other guard conditions and will be chosen when all other conditions turn out to be false.

3DUWLFLSDQW $ 3DUWLFLSDQW %

<HV 'HFLVLRQ" 7DVN
1R

7DVN 7DVN

<HV 'HFLVLRQ" 7DVN
1R

7DVN 7DVN

1 VAR

2 ¬´ExclusiveDecision¬ª: boolean;

3 ¬´ParticipantB_Task1_Rec¬ª : boolean;

4 ...

5 ¬´ParticipantB_Task3_Snd¬ª : boolean;

6 -- abstraction of boolean expressions

7 ¬´guard_1¬ª : boolean;

8 -- temporary variable

9 ¬´post_decision_i¬ª : {undetermined, ¬´out_yes¬ª, ¬´out_no¬ª};

10 ASSIGN

11 init(¬´ExclusiveDecision¬ª) := FALSE;

12 next(¬´ExclusiveDecision¬ª) := case

13

¬´ExclusiveDecision¬ª : FALSE;

14 esac;

15 ... -- the initializations of guards are omitted

16 init(¬´post_decision_i¬ª) := undetermined;

17 next(¬´post_decision_i¬ª) := case

18

¬´ExclusiveDecision¬ª & ¬´guard_1¬ª : ¬´out_yes¬ª;

19

¬´ExclusiveDecision¬ª & ¬´guard_2¬ª : ¬´out_no¬ª;

20

TRUE : undetermined;

21 esac;

22 init(¬´ParticipantB_Task2_Snd¬ª) := FALSE;

23 next(¬´ParticipantB_Task2_Snd¬ª) := case

24

¬´post_decision_i¬ª = ¬´guard_1¬ª : TRUE;

25

¬´ParticipantB_Task2_Snd¬ª : FALSE;

26 esac;

27 init(¬´ParticipantB_Task3_Snd¬ª) := FALSE;

28 next(¬´ParticipantB_Task3_Snd¬ª) := case

29

¬´post_decision_i¬ª = ¬´guard_2¬ª : TRUE;

30

¬´ParticipantB_Task3_Snd¬ª : FALSE;

31 esac;

Fig. 4: SMV Generation Rules for Exclusive Decision
An Inclusive Decision represents the execution of any number of branches instead of one or all. The translation rules of Inclusive Decision are similar to Exclusive Decision; however, a ‚Äútrue‚Äù evaluation of one guard condition does not exclude the evaluation of other guard conditions. All sequence Ô¨Çows with a ‚Äútrue‚Äù evaluation will be traversed by a token. The Event-based gateway represents an alternative branching point where the decision is made by two or more

176

events; for instance, the choice for an outgoing sequence Ô¨Çow is made when an event will occur on the particular outgoing Ô¨Çow. When execution of process arrives at the particular point, the execution stops until either the message event or the timer event occurs. However, the occurrence of Ô¨Årst event will immediately continue its outgoing sequence Ô¨Çow by disabling the other paths. In this case, a boolean variable wait_event is used to indicate that the outgoing Ô¨Çows can not be proceed until an event is occurred. The SMV descriptions of Inclusive Decision and Event-based gateways can be derived from the Exclusive Decision. The complete translation details cannot be presented due to space reasons and similar technical details.
3) Exclusive Merge and Inclusive Merge: An Exclusive Merge brings together multiple alternative interactions and exclusively accepts one among them. If an Exclusive Merge has two incoming interactions, a straightforward naive encoding strategy is to use the xor operator ‚ÄúParticipantB_Task1_Rec xor ParticipantB_Task2_Rec‚Äù to express the incoming guard condition of an Exclusive Merge. However, this strategy cannot be effectively generalised for Exclusive Merge that has more than two incoming sequence Ô¨Çows because the operator ‚Äúxor‚Äù with n operands (n ‚â• 3) yields true not only when one of its operands is true but also when the odd numbers of the operands are true [8]. Exclusive Merge is therefore implemented by its equivalent but longer form ‚Äú(ParticipantB_Task1_Rec ‚àß ¬¨ParticipantB_Task2_Rec) ‚à® (¬¨ParticipantB_Task1_Rec ‚àß ParticipantB_Task2_Rec)‚Äù.

3DUWLFLSDQW $ 3DUWLFLSDQW %

7DVN 7DVN

7DVN

7DVN 7DVN

7DVN

1 VAR

2 ¬´ParticipantB_Task1_Rec¬ª : boolean;

3 ¬´ExclusiveMerge¬ª : boolean;

4 ¬´merge_flag_i¬ª : {undetermined, ¬´in_t1¬ª, ¬´in_t2¬ª}

5 ASSIGN

6 ... -- the initializations and transitions of tasks are omitted

7 init(¬´merge_flag_i¬ª) := undetermined;

8 next(¬´merge_flag_i¬ª):= case

9

(¬´merge_flag_i¬ª = undetermined) & (¬´ParticipantB_Task1_Rec¬ª

| ¬´ParticipantB_Task2_Rec¬ª): {¬´in_t1¬ª, ¬´in_t2¬ª};

10

TRUE : undetermined;

11 esac;

12 init(¬´ExclusiveMerge¬ª) := FALSE;

13 next(¬´ExclusiveMerge¬ª) := case

14

¬´ParticipantB_Task1_Rec¬ª & ! ¬´ParticipantB_Task2_Rec¬ª :

TRUE;

15

! ¬´ParticipantB_Task1_Rec¬ª & ¬´ParticipantB_Task2_Rec¬ª :

TRUE;

16

¬´merge_flag_i¬ª = ¬´in_t1¬ª | ¬´merge_flag_i¬ª = ¬´in_t2¬ª : TRUE

;

17

¬´ExclusiveMerge¬ª : FALSE;

18 esac;

Fig. 5: SMV Generation Rules for Exclusive Merge

In order to avoid name conÔ¨Çicts, a temporary variable merge_flag_i is introduced for each Exclusive Merge, where i represents an incrementally generated number to avoid name conÔ¨Çicts, as shown in Figure 5. This temporary variable has an enumerated type that comprises ‚Äúundetermined‚Äù and

‚Äúin_tx‚Äù. The former denotes the normal state; whereas the latter represent the state values that correspond to the incoming sequence Ô¨Çows (x = 1, ..., n). As we see in Line 9, one branch will be non-deterministically and exclusively selected from the activated branches. That is, in order to verify in case some k (k ‚â§ n) incoming interactions are simultaneously activated, NuSMV will bind merge_flag_i to a certain value ‚Äúin_tx‚Äù in the Ô¨Årst place, to ‚Äúundetermined‚Äù in the next transition, then to another value ‚Äúin_ty‚Äù in the subsequent transition, and so forth. In combination with the branching construct ‚Äúcase/esac‚Äù (Line 12‚Äì18), we can see that the Exclusive Merge is activated if and only if either one of the incoming interactions is true or the variable merge_flag_i is assigned to a state value ‚Äúin_tx‚Äù, where x = 1, ..., n.
An Inclusive Merge has similar semantics to Exclusive Merge; however, it brings together not only multiple alternatives but also parallel interactions and accepts one or more among them. In the case of Inclusive Merge, we use the logical OR operator (‚Äú|‚Äù) to express the incoming guard condition instead of xor operator.
C. Containment Checking and Dealing with Violations
This section is devoted to the identiÔ¨Åcation of containment problems and their resolutions. The containment violations may occur due to a variety of reasons, such as (i) missing participant or interaction ‚Äì a participant or interactions exist in the global model may not exist in the local choreography models; (ii) misplacement of elements ‚Äì the local choreography model contains interactions with participant speciÔ¨Åed in the global choreography model but with different structure. To alleviate containment checking problems, an efÔ¨Åcient analysis of the generated counterexample is supported in the proposed approach. The automated counterexample analysis not only detects the actual causes of the unsatisÔ¨Åed containment relationship but also provides appropriate guidelines to resolve the particular violations. Therefore, the output trace Ô¨Åle is scrutinised and parsed to determine the unsatisÔ¨Åed LTL formulas. The extracted formulas and SMV descriptions together with LTL-based transformation rules are traversed to Ô¨Ånd out why the elements of the global choreography model are not matched with their corresponding local choreography counterparts. This is performed in two steps. Firstly, the missing element cause (either one, multiple, or all elements could be missing) is detected and the countermeasure (i.e., insert the missing element at a particular position in the model) is suggested. Secondly, the sequence of elements from the SMV descriptions is scrutinised and corresponding elements (e.g., tasks, gateways and so on) causing the violation of the LTL formulas are located (i.e., misplacement of elements) and relevant countermeasures (i.e., add, delete or replace the element after or before the particular element) are suggested.
The counterexample analysis results are presented in Figure 6. The gray boxes display the actual causes and potential countermeasures of the unsatisÔ¨Åed formulas. Furthermore, the elements responsible for causing the containment violation are highlighted in red; whereas the elements that satisÔ¨Åed the

177

rule are highlighted in green. In this case, the containment relationship is not satisÔ¨Åed due to the violation of sequential rules. The receiving rule for the RequestBooking and CreditDetails messages is violated because traveller invokes the travel agency by sending RequestBooking message before CreditDetails message; however, travel agency receives the CreditDetails message before the RequestBooking message. This implies that either receiving event of one or both tasks are misplaced. It can be resolved by putting the CreditDetails receive task after the RequestBooking receive task in the local choreography model of travel agency.

7U DYHO OHU

%RRNLQJ 5HTXHVW &UHGLW 'HWDLOV

1RW $YDLODEOH

%RRNLQJ 6WDWXV $FFHSW 2IIHU
&DXVH  ¬≥7UDYHO$JHQF\B%RRNLQJ5HTXHVWB5HF¬¥ GRHV QRW IROORZ ¬≥7UDYHOOHUB&UHGLW'HWDLOVB6QG¬¥  ¬≥7UDYHO$JHQF\B&UHGLW'HWDLOVB5HF¬¥ GRHV QRW H[LVW EHIRUH ¬≥7UDYHO$JHQF\B%RRNLQJ5HTXHVWB5HF¬¥ &RXQWHUPHDVXUHV  6ZDS WKH UHFHLYLQJ WDVN RI ¬≥%RRNLQJ5HTXHVW¬¥ PHVVDJH DQG ¬≥&UHGLW'HWDLOV¬¥  $GG ¬≥&UHGLW'HWDLOVB5HF¬¥ WDVN DIWHU ¬≥%RRNLQJ5HTXHVWB5HF¬¥ WDVN LQ 7UDYHO$JHQF\

7UDYHO ,WLQHUDU\ 8QDXWKRUL]HG &UHGLW &DUG

7UDYHO $JHQF\

&UHGLW 'HWDLOV 1RW $YDLODEOH $XWKRUL]H &UHGLW &DUG

)DLOXUH 8QDXWKRUL]HG &UHGLW &DUG

1R %RRNLQJ 5HTXHVW
&KHFN DYDLODELOLW\" <HV %RRNLQJ 6WDWXV

$SSURYHG

7UDYHO ,WLQHUDU\ 3XUFKDVH &RQILUPDWLRQ

$FFHSW 2IIHU %RRN )OLJKW 5HVHUYH 5RRP 5HQWDO 5HTXHVW

H7LFNHW

&DXVH  ¬≥7UDYHO$JHQF\B3XUFKDVH&RQILUPDWLRQB5HF¬¥ GRHV QRW H[LVW EHIRUH ¬≥7UDYHO$JHQF\BH7LFNHWB5HF¬¥ &RXQWHUPHDVXUHV  $GG ¬≥H7LFNHWB5HF¬¥ WDVN DIWHU ¬≥3XUFKDVH&RQILUPDWLRQB5HF¬¥ WDVN LQ 7UDYHO$JHQF\  5HPRYH $1'6SOLW DQG $1'-RLQ

&RQILUP 5HVHUYDWLRQ 9HKLFOH $VVLJQ

&DXVH  ¬≥$LUOLQHBH7LFNHWB6QG¬¥ GRHV QRW IROORZ ¬≥$LUOLQHB3XUFKDVH&RQILUPDWLRQB6QG¬¥ &RXQWHUPHDVXUHV  $GG ¬≥H7LFNHWB6QG¬¥ WDVN DIWHU ¬≥3XUFKDVH&RQILUPDWLRQB6QG¬¥ WDVN LQ $LUOLQH  5HPRYH $1'6SOLW DQG $1'-RLQ

$ LU OL Q H

%RRN )OLJKW

3XUFKDVH &RQILUPDWLRQ H7LFNHW

Fig. 6: Visual Support for Understanding and Resolving Containment Violations

Similarly, the primary root causes of other violations are due to the execution of PurchaseConfirmation and eTicket messages in parallel order instead of sequential order. These violations can be resolved by deleting forks and joins, and putting the e-Ticket message after the PurchaseConfirmation message in the local choreography models of travel agency and airline. Once the causes are located, they are eliminated by updating the responsible elements of the choreography models and rerunning the containment checking process yielded no further violations. Without the counterexample analysis, users would have to study and investigate the syntax and semantics of the trace Ô¨Åle in order to determine the relationship between the execution traces and the service choreography models, and then locate the corresponding violation within models, meaning that the complex matching between the variables and states in the counterexample and the elements of the choreography models is performed manually. This is especially cumbersome for those having limited knowledge of the underlying formal techniques.

IV. EVALUATION
We implement containment checking approach and conduct a preliminary evaluation of its performance. The main idea is to validate whether the proposed approach performs reasonably for typical models used in industry on typical workstations used by developers. The workstation used for the performance evaluation is running under Windows 8 on a 2.6 GHz i5 processor with 8GB of memory using NuSMV 2.5.4. The evaluation is conducted through three behaviour models of different sizes and complexity that are taken from our previous industry projects. One of them is the Travel Booking (TB) mentioned in the previous section. The other two are Automated Teller Machine (ATM) and Order Processing (OP). We omit the details of OP and ATM scenarios due to space limitations. Table II shows the complexity of the input BPMN model (GCM = global choreography model, LCMi = local choreography models) with respect to their elements including tasks, gateways, and edges (sequence and message Ô¨Çows).

TABLE II: Model Size and Translation Time

,QSXW VL]H
*DWHZD\V ,QWHUDFWLRQV (GJHV 7RWDO (OHPHQWV 0RGHO /RDGLQJ PV 7UDQVODWLRQ 7LPH PV

23 *&0     ¬ì  ¬ì

/&0L     ¬ì  ¬ì 

7% *&0     ¬ì  ¬ì

/&0L     ¬ì ¬ì

$70 *&0     ¬ì  ¬ì

/&0L     ¬ì  ¬ì

Table III shows the total execution time of three models, reachable states and violated formulas. The evaluation results indicate that the containment checking time spent by NuSMV for the TB process is longer than the ATM and OP. This is because NuSMV found violations between the formal descriptions of the LCMi and LTL formulas of the GCM and thus NuSMV needed to generate a counterexample for violated LTL formula. The evaluation results demonstrate that our approach efÔ¨Åciently translates service choreography models into formal descriptions and consistency constraints for supporting containment checking. In particular, all realistic scenarios are handled in a total time around a second which is quite reasonable for practical purposes. Our analysis and evaluation results based on the aforementioned use case scenarios show the feasibility of our approach for larger systems.

TABLE III: Performance Evaluation Results

&RQWDLQPHQW FKHFNLQJ 9HULILFDWLRQ 7LPH PV 7RWDO 7LPH PV 9LRODWHG )RUPXODV 5HDFKDEOH 6WDWHV 7RWDO 6WDWHV

23 ¬ì   RXW RI   √ñ H√ñ

7% ¬ì   RXW RI  H A H A

$70 ¬ì   RXW RI   √ñ H√ñ

V. RELATED WORK
Zaha et al. [1] propose the algorithms for generating local models (i.e., provider behaviour) from global models and for verifying the local enforceability of global models. Yu et al. [9] propose an approach for the speciÔ¨Åcation of properties called PROPOLS and for veriÔ¨Åcation of BPEL schemas. The approach Ô¨Årst translated the BPEL schemas and PROPOLS into Finite State Automatas (FSAs), then compares these FSAs. However, the approach does not deal with the service choreographies. Kwantes et al. [2] present the translation of the

178

BPMN collaboration diagram into an LTL formula to check conformance with local workÔ¨Çows as BPMN process diagrams using GROOVE tool. However, the translation has been done manually.
Poizat and Sala√ºn [10] introduce the LOTOS NT process algebra formalism for BPMN choreographies to validate the realizability between models using the CADP state space exploration tools. In particular, the interactions produced by the global choreography model and communicating peer processes are compared. Fu et al. [11] present a formal speciÔ¨Åcation, veriÔ¨Åcation, and analysis tool for web service compositions based on guarded automata (GA). BPEL speciÔ¨Åcations are translated to GA and then mapped to Promela, the input language of the SPIN model checker. Solaiman et al. [12] developed a BPMNveriÔ¨Åer tool that automatically converts BPMN choreography models into Promela. However, the LTL properties are manually created or otherwise retrieved for the generated Promela models; they are stored in a repository. These approaches require a considerable amount of knowledge of temporal logics properties.
In the course of our earlier research, we have investigated the containment checking problem for activity diagrams [13] and sequence diagrams [14]. In addition to the model checking based techniques, a lightweight graph-based approach has been proposed that veriÔ¨Åes missing nodes, missing transitive links, and missing cycles [15]. This research focuses on the containment relationship between global and local choreography models, which has not been considered in the literature. The proposed approach not only provides formalisation for automated transformation of global and local choreography models into consistency constraints and formal descriptions, but also gives more informative and comprehensive feedbacks to developers/architects for identifying the causes of containment violations and their resolutions.
VI. CONCLUSION
Motivated by the need to support the containment checking in service choreographies, we introduced a set of transformation rules to facilitate the automated transformation of global and local choreography models into LTL constraints and SMV descriptions, respectively. This provides efÔ¨Åcient means for automated generation of consistency constraints and formal descriptions for large and complex choreography models. The results produced by the model checkers (i.e., counterexamples) are rather cryptic and verbose, and thus, tracking the entire evidence is difÔ¨Åcult for architects/developers. In order to mitigate the need for strong background of formal techniques, the counterexample analysis mechanism is integrated that provides more informative and comprehensive feedbacks to the stakeholders for identiÔ¨Åcation of containment problems and their resolutions. To illustrate the applicability of the proposed approach, we realized use case scenarios of ATM machine, travel booking and order processing systems; the performance evaluation is also carried out in particular cases. By analysing the evaluation results we found that our approach efÔ¨Åciently translates choreography models into formal speciÔ¨Åcations and

works well for larger realistic scenarios. In the future, we
plan to conduct controlled experiments with participants from
industry and academia to empirically validate whether the
proposed approach signiÔ¨Åcantly supports human analysts in
identiÔ¨Åcation and resolution of containment inconsistencies.
ACKNOWLEDGMENT
This work is supported by the Wiener Wissenschafts-
, Forschungs- und Technologiefonds (WWTF), Grant No.
ICT12-001 and University of Vienna.
REFERENCES
[1] J. M. Zaha, M. Dumas, A. t. Hofstede, A. Barros, and G. Decker, ‚ÄúService interaction modeling: Bridging global and local views,‚Äù in Proceedings of the 10th IEEE International Enterprise Distributed Object Computing Conference, ser. EDOC ‚Äô06, Hong Kong, China, 2006, pp. 45‚Äì55.
[2] P. M. Kwantes, P. V. Gorp, J. Kleijn, and A. Rensink, ‚ÄúTowards compliance veriÔ¨Åcation between global and local process models,‚Äù in Proceedings of the 8th International Conference on Graph Transformation, ser. STAF ‚Äô15, L‚ÄôAquila, Italy, 2015, pp. 221‚Äì236.
[3] F. U. Muram, H. Tran, and U. Zdun, ‚ÄúCounterexample analysis for supporting containment checking of business process models,‚Äù in Business Process Management Workshops - BPM 2015, 13th International Workshops, Innsbruck, Austria, August 31 - September 3, 2015, Revised Papers, 2015, pp. 515‚Äì528.
[4] A. Pnueli, ‚ÄúThe temporal logic of programs,‚Äù in 18th Annual Symposium on Foundations of Computer Science, ser. SFCS ‚Äô77. IEEE Computer Society, 1977, pp. 46‚Äì57.
[5] A. Cimatti, E. M. Clarke, F. Giunchiglia, and M. Roveri, ‚ÄúNusmv: A new symbolic model veriÔ¨Åer,‚Äù in Proceedings of the 11th International Conference on Computer Aided VeriÔ¨Åcation, ser. CAV ‚Äô99, Trento, Italy, 1999, pp. 495‚Äì499.
[6] Object Management Group (OMG), ‚ÄúBusiness Process Model and Notation (BPMN) Version 2.0.‚Äù http://www.omg.org/spec/BPMN/2.0, last accessed: May 9, 2017.
[7] K. Y. Rozier, ‚ÄúSurvey: Linear temporal logic symbolic model checking,‚Äù Comput. Sci. Rev., vol. 5, no. 2, pp. 163‚Äì203, May 2011.
[8] F. Pelletier, ‚ÄúTernary Exclusive Or,‚Äù Logic Journal of the Igpl, vol. 16, no. 1, pp. 75‚Äì83, 2008.
[9] J. Yu, T. P. Manh, J. Han, Y. Jin, Y. Han, and J. Wang, ‚ÄúPattern based property speciÔ¨Åcation and veriÔ¨Åcation for service composition,‚Äù in Proceedings of the 7th International Conference on Web Information Systems, ser. WISE‚Äô06. Berlin, Heidelberg: Springer-Verlag, 2006, pp. 156‚Äì168.
[10] P. Poizat and G. Sala√ºn, ‚ÄúChecking the realizability of bpmn 2.0 choreographies,‚Äù in Proceedings of the 27th Annual ACM Symposium on Applied Computing, ser. SAC ‚Äô12, Trento, Italy, 2012, pp. 1927‚Äì 1934.
[11] X. Fu, T. Bultan, and J. Su, ‚ÄúWSAT: A tool for formal analysis of web services,‚Äù in Proceedings of the 16th International Conference on Computer Aided VeriÔ¨Åcation, ser. CAV ‚Äô04, Boston, MA, USA‚Äû 2004, pp. 510‚Äì514.
[12] E. Solaiman, W. Sun, and C. Molina-Jimenez, ‚ÄúA tool for the automatic veriÔ¨Åcation of bpmn choreographies,‚Äù in Proceedings of the 2015 IEEE International Conference on Services Computing, ser. SCC ‚Äô15. Washington, DC, USA: IEEE Computer Society, 2015, pp. 728‚Äì735.
[13] F. U. Muram, H. Tran, and U. Zdun, ‚ÄúAutomated Mapping of UML Activity Diagrams to Formal SpeciÔ¨Åcations for Supporting Containment Checking,‚Äù in 11th Int‚Äôl Workshop on Formal Engineering approaches to Software Components and Architectures (FESCA), Grenoble, France, Apr. 2014, pp. 93‚Äì107.
[14] ‚Äî‚Äî, ‚ÄúA model checking based approach for containment checking of uml sequence diagrams,‚Äù in 23rd Asia-PaciÔ¨Åc Software Engineering Conference (APSEC). Hamilton, New Zealand: IEEE Computer Society, 2016.
[15] H. Tran, F. Ul Muram, and U. Zdun, ‚ÄúA graph-based approach for containment checking of behavior models of software systems,‚Äù in Proceedings of the 2015 IEEE 19th International Enterprise Distributed Object Computing Conference, ser. EDOC ‚Äô15, Adelaide, SA, Australia, 2015, pp. 84‚Äì93.

179

