Cours- Formation LoRa / LoRaWAN
Version du cours : 4.0 Mars 2019
Sylvain MONTAGNY sylvain.montagny@univ-smb.fr Universit√© Savoie Mont Blanc

Pr√©sentation du document
Ce cours sur l‚Äôinternet des Objets et les protocoles LoRa / LoRaWAN est le support d‚Äôune formation propos√©e par l‚ÄôUniversit√© de Savoie Mont Blanc (USMB). Elle est r√©alis√©e :
‚ñ† Aux √©tudiants du Master ESET (Electronique des Syst√®mes Embarqu√©s et T√©l√©coms) Site web de la formation : [ www.master-electronique.com ]
‚ñ† Aux entreprises qui en font la demande (1 ou 2 journ√©es) : sylvain.montagny@univ-smb.fr

Ce cours est mis √† disposition sur internet et est libre d‚Äôutilisation. Toutes personnes souhaitant apporter des modifications / am√©liorations / corrections peut le faire sur l‚Äôadresse mail : sylvain.montagny@univ-smb.fr . L‚Äôauteur vous remercie par avance pour votre contribution.

LoRa : LoRaWAN : LPWAN : TTN : MQTT : QoS : HTTP : IoT : LTE-M : NB-IoT : FDM : TDM : CDMA : RSSI : SNR : SF : CR : CHIRP : JSON : SDR :

Sigles et Acronymes
Long Range Long Rang Wide Area Network Low Power Wide Area Network. The Things Network Message Queuing Telemetry Transport Quality of Service HyperText Transfer Protocol Internet Of Things Long Term Evolution Cat M1 NarrowBand Internet of Things Frequency Division Multiplexing Time Division Multiplexing Code Division Multiple Access Received Signal Strength Indication. Signal Over Noise Ratio Spreading Factor Coding Rate Compressed High Intensity Radar Pulse JavaScript Object Notation Software Digital Radio

|2

Sommaire
1 LES SYSTEMES EMBARQUES ET L‚ÄôIOT ................................................................................................... 6
1.1 L'INTERNET DES OBJETS ( INTERNET OF THINGS / IOT ) .................................................................................. 6 1.1.1 Les syst√®mes embarqu√©s dans l‚ÄôIoT .............................................................................................. 6 1.1.2 Diff√©rents protocoles dans l‚ÄôIoT .................................................................................................... 6 1.1.3 Bande de fr√©quence utilis√©es......................................................................................................... 7
1.2 MODES DE PARTAGE DU SUPPORT.............................................................................................................. 7 1.3 NOTION D‚ÄôETALEMENT DE SPECTRE ............................................................................................................ 8
1.3.1 Transmissions successives ............................................................................................................. 8 1.3.2 Transmissions simultan√©es............................................................................................................ 9 1.3.3 Cas du protocole LoRa................................................................................................................... 9
2 TRANSMISSION RADIO ET PROPAGATION ......................................................................................... 10
2.1 LES UNITES ET DEFINITIONS..................................................................................................................... 10 2.2 ETUDE DE LA DOCUMENTATION D‚ÄôUN COMPOSANT LORA............................................................................. 11
3 LA COUCHE PHYSIQUE LORA.............................................................................................................. 13
3.1 LA MODULATION LORA ......................................................................................................................... 13 3.1.1 La forme du symbole (Chirp) ....................................................................................................... 13 3.1.2 Dur√©e d‚Äô√©mission d‚Äôun symbole .................................................................................................. 15
3.2 CODING RATE ...................................................................................................................................... 16 3.3 UTILISATION DU LORA CALCULATOR ........................................................................................................ 17 3.4 TIME ON AIR....................................................................................................................................... 18 3.5 MISE EN ≈íUVRE : LORA EN POINT A POINT................................................................................................ 19
3.5.1 Utilisation de l‚ÄôIDE Arduino ......................................................................................................... 19 3.5.2 Validation du fonctionnement .................................................................................................... 20 3.5.3 Mise en valeur du Spreading Factor............................................................................................ 20
4 LE PROTOCOLE LORAWAN ................................................................................................................. 21
4.1 STRUCTURE D‚ÄôUN RESEAU LORAWAN ..................................................................................................... 21 4.1.1 Les Devices LoRa ......................................................................................................................... 21 4.1.2 Les Gateways LoRa...................................................................................................................... 21 4.1.3 Le Network Server ....................................................................................................................... 22 4.1.4 Application Server ....................................................................................................................... 22 4.1.5 Application / Web Serveur .......................................................................................................... 24 4.1.6 Authentification avec le Network Server..................................................................................... 25 4.1.7 Chiffrement des donn√©es vers l‚ÄôApplication Server ..................................................................... 25 4.1.8 Combinaison de l‚Äôauthentification et du chiffrement ................................................................. 26
4.2 CLASSES DES DEVICES LORAWAN ........................................................................................................... 26 4.2.1 Classe A (All) : Minimal power Application ................................................................................. 26 4.2.2 Classe B (Beacon) : Scheduled Receive Slot ................................................................................. 27 4.2.3 Classe C (Continuous) : Continuously Listening ........................................................................... 28 4.2.4 Quelle Gateway pour les flux Downlink ?.................................................................................... 29
4.3 ACTIVATION DES DEVICES LORA ET SECURITE ............................................................................................. 29 4.3.1 ABP : Activation By Personalization ............................................................................................ 29 4.3.2 OTAA : Over The Air Activation : ................................................................................................. 30 4.3.3 S√©curit√© ....................................................................................................................................... 31
4.4 LA TRAME LORA / LORAWAN ............................................................................................................... 32 4.4.1 Les couches du protocole LoRaWAN ........................................................................................... 32 4.4.2 Couche Application ..................................................................................................................... 33 4.4.3 Couche LoRa MAC ....................................................................................................................... 34
|3

4.4.4 4.4.5 4.4.6 4.4.7

Couche physique : Modulation LoRa ........................................................................................... 34 Canaux et bandes de fr√©quences et Data Rate (DR) ................................................................... 35 Trame re√ßue et transmise par la Gateway LoRaWAN ................................................................. 36 Le format JSON............................................................................................................................ 37

5 MISE EN ≈íUVRE D‚ÄôUN RESEAU LORAWAN ........................................................................................ 38

5.1 LES DIFFERENTS TYPES DE RESEAUX........................................................................................................... 38 5.1.1 Les r√©seaux LoRaWAN op√©r√©s ..................................................................................................... 38 5.1.2 Les r√©seaux LoRaWAN priv√©s ...................................................................................................... 38 5.1.3 Les zones de couvertures............................................................................................................. 38
5.2 THE THINGS NETWORK (TTN) ................................................................................................................ 39 5.2.1 Pr√©sentation de TTN.................................................................................................................... 39 5.2.2 Configuration de la Gateway ...................................................................................................... 39 5.2.3 Enregistrement des Gateways, Appplication et Devices ............................................................. 39 5.2.4 Configuration des Devices LoRa .................................................................................................. 40
5.3 MISE EN APPLICATION ........................................................................................................................... 41 5.4 ANALYSE DES TRAMES ECHANGEES ........................................................................................................... 41
5.4.1 Utilisation de la base 64 .............................................................................................................. 41 5.4.2 Int√©r√™t et inconv√©nient de la base 64 .......................................................................................... 43 5.4.3 Uplink : Du Device LoRa au Network Server ................................................................................ 43 5.4.4 Uplink : Du Network Server √† l‚ÄôApplication Server ...................................................................... 45 5.4.5 Simulation d‚ÄôUplink dans l‚ÄôApplication Server ............................................................................ 46 5.4.6 Downlink : De l‚ÄôApplication Server au Device LoRa ..................................................................... 46

6 LA RECUPERATION DES DONNEES SUR NOTRE PROPRE APPLICATION ............................................... 47

6.1 RECUPERATION DES DONNEES EN HTTP POST DANS L‚ÄôAPPLICATION.............................................................. 47 6.1.1 Pr√©sentation du protocole HTTP ................................................................................................. 47 6.1.2 Fonctionnement d‚Äôun client et d‚Äôun serveur HTTP POST ............................................................. 48 6.1.3 Test du serveur HTTP POST ......................................................................................................... 49 6.1.4 Test du client HTTP POST ............................................................................................................ 49 6.1.5 R√©cup√©rer des donn√©es sur notre Application avec HTTP POST .................................................. 49 6.1.1 Envoyer des donn√©es depuis notre Application avec HTTP POST ................................................ 51
6.2 RECUPERATION DES DONNEES AVEC MQTT DANS L‚ÄôAPPLICATION .................................................................. 52 6.2.1 Pr√©sentation du protocole MQTT ................................................................................................ 52 6.2.2 Connexion au Broker MQTT ........................................................................................................ 53 6.2.3 Qualit√© de Service au cours d'une m√™me connexion ................................................................... 53 6.2.4 Qualit√© de Service apr√®s une reconnexion .................................................................................. 55 6.2.5 Les Topics du protocole MQTT .................................................................................................... 55 6.2.6 Mise en place d‚Äôun Broker MQTT ................................................................................................ 56 6.2.7 Mise en place d‚Äôun Publisher et d‚Äôun Subscriber MQTT .............................................................. 57 6.2.8 R√©cup√©rer des donn√©es sur notre Application avec MQTT .......................................................... 57 6.2.9 Envoyer des donn√©es depuis notre Application avec MQTT........................................................ 60

7 CREATION DE NOTRE PROPRE NETWORK ET APPLICATION SERVER ................................................... 63

7.1.1 Objectifs ...................................................................................................................................... 63 7.1.2 Pr√©sentation de LoRaServer ........................................................................................................ 63 7.1.3 Le ¬´ Packet Forwarder ¬ª (Gateway) ............................................................................................ 64 7.1.4 LoRa Gateway Bridge .................................................................................................................. 66 7.1.5 LoRa Server (Network Server) ..................................................................................................... 66 7.1.6 LoRa App Server (Application Server).......................................................................................... 67 7.1.7 LoRa Geo Server .......................................................................................................................... 67 7.1.8 Application .................................................................................................................................. 67 7.2 INSTALLATION DE LORASERVER ............................................................................................................... 67

|4

7.2.1 Mise en place de l‚Äôenvironnement .............................................................................................. 67 7.2.2 Installation sur la Raspberry PI ................................................................................................... 68 7.1 CONFIGURATION DE LORA SERVER POUR L'UPLINK ..................................................................................... 69 7.1.1 Enregistrement d‚Äôune nouvelle Organisation.............................................................................. 69 7.1.2 Enregistrement d‚Äôune instance du Network Server..................................................................... 69 7.1.3 Enregistrement d‚Äôune Application (Sur l‚ÄôApplication Server) ...................................................... 70 7.1.4 Enregistrement des Devices LoRa ............................................................................................... 71 7.1.5 Visualisation des trames re√ßues .................................................................................................. 72 7.2 CONFIGURATION DE LORASERVER POUR L'INTEGRATION D'APPLICATION......................................................... 74 7.2.1 R√©cup√©rer des donn√©es sur notre Application avec HTTP POST .................................................. 74 7.2.2 R√©cup√©rer des donn√©es sur notre Application avec MQTT.......................................................... 74 8 CREATION DE NOTRE PROPRE APPLICATION ..................................................................................... 76 8.1 UTILISATION DE NODE-RED ................................................................................................................... 76 8.1.1 Pr√©sentation ................................................................................................................................ 76 8.1.2 Mise en place de l‚Äôenvironnement .............................................................................................. 76 8.1.3 Cr√©er une Application sp√©cifique pour TTN ................................................................................. 77 8.1.4 Cr√©ation d‚Äôun Dashboard ............................................................................................................ 79 8.2 PROGRAMMATION EN PHP .................................................................................................................... 80 9 VERSIONS DU DOCUMENT ................................................................................................................. 82
|5

1 Les syst√®mes embarqu√©s et l‚ÄôIoT
1.1 L'Internet des Objets ( Internet of Things / IoT )
1.1.1 Les syst√®mes embarqu√©s dans l‚ÄôIoT D‚Äôune fa√ßon g√©n√©rale, les syst√®mes √©lectroniques peuvent √™tre caract√©ris√©s par leur consommation, leur puissance de calcul, leur taille et leur prix. Dans le cas sp√©cifique des syst√®mes embarqu√©s utilis√©s dans l‚ÄôIoT, nous pouvons affecter le poids suivant √† chacune des caract√©ristiques :
Figure 1 : Consommation, Puissance, Taille et Prix des objets connect√©s Compar√©s aux autres syst√®mes √©lectroniques, les syst√®mes embarqu√©s utilis√©s dans l‚ÄôIoT poss√®dent donc :
‚ñ† Une faible consommation ‚ñ† Une faible puissance de calcul ‚ñ† Une petite taille ‚ñ† Un prix faible
1.1.2 Diff√©rents protocoles dans l‚ÄôIoT Citez les diff√©rents protocoles que vous connaissez dans le mode de l‚ÄôIoT (Internet Of Things) et reportez-les dans le graphique ci-dessous en fonction de leur bande passante et de leur port√©e.
|6

D√©bit (Bandwidth)

Figure 2 : Protocoles utilis√©s dans l'IoT en fonction du d√©bit et de la port√©e

Port√©e (Range)

Dans l‚ÄôIoT, les protocoles utilis√©s poss√®dent une grande port√©e, et des d√©bits faibles

L‚Äôensemble de ces r√©seaux sont d√©nomm√©s LPWAN : Low Power Wide Area Network.
1.1.3 Bande de fr√©quence utilis√©es En Europe les bandes de fr√©quences libres (sans licence) sont :
13 Mhz (RFID), 169 Mhz, 434 Mhz, 868 Mhz, 2.4Ghz, 5 Ghz et 24 Ghz (Faisceau Hertzien). Parmi ces fr√©quences, seul le 433 MHz et 868 MHz sont utilisables en LoRa.
1.2 Modes de partage du support
Quel que soit le protocole utilis√©, le support de transfert de l‚Äôinformation est l‚Äôair, car tous les protocoles de l‚ÄôIoT sont Wireless. Le support doit √™tre partag√© entre tous les utilisateurs de telle fa√ßon que chacun des dispositifs Wireless ne perturbe pas les autres. Pour cela une bande de fr√©quence est allou√©e. Par exemple pour la radio FM la bande de fr√©quence va de 87,5 Mhz √† 108 Mhz.
Dans leur bande de fr√©quence les dispositifs peuvent se partager le support de diff√©rentes mani√®res :
‚ñ† FDM (Frequency Division Multiplexing) : Ce mode utilise une partie du spectre (bande de fr√©quence), en permanence. Exemple : Radio FM.
‚ñ† TDM (Time Division Multiplexing). Ce mode utilise tout le spectre (bande de fr√©quence), par intermittence. Exemple : GSM, on a ¬´ 8 time slots ¬ª par canal.
‚ñ† CDMA (Code Division Multiple Access) : Ce mode utilise tout le spectre, tout le temps.

Les Devices LoRa sont capables d‚Äô√©mettre sur un m√™me canal, en m√™me temps. Le protocole LoRa utilise une modulation tr√®s similaire √† la m√©thode de partage CDMA (pour autant, on ne pourra pas dire que le LoRa utilise le CDMA). Afin de comprendre la pertinence de ce mode de partage du support, nous allons valider le fonctionnement du mode CDMA dans le prochain paragraphe. Plus tard dans le cours, nous expliquerons les diff√©rences de la modulation LoRa.
1.3 Notion d‚Äô "√©talement de spectre" utilis√©e en LoRa
Nous allons voir au travers d‚Äôun exercice comment il est possible d‚Äôutiliser tout le spectre, en permanence, tout en √©tant capable d‚Äôeffectuer plusieurs transactions simultan√©es entre diff√©rents √©metteurs/r√©cepteurs. Cette m√©thode est souvent appel√©e ¬´ √©talement de spectre ¬ª car comme son nom l‚Äôindique, elle a pour cons√©quence d‚Äô√©taler le spectre du signal transmis.
La m√©thode consiste √† utiliser des codes qui ont des propri√©t√©s math√©matiques adapt√©es √† notre objectif : Transmettre en m√™me temps sur la m√™me bande de fr√©quence. La matrice ci-dessous donne par exemple 4 codes d‚Äô√©talement (1 par ligne) :
Code Orthogonal User 0 1 1 1 1 Code Orthogonal User 1 1 -1 1 -1 Code Orthogonal User 2 1 1 -1 -1 Code Orthogonal User 3 1 -1 -1 1 Tableau 1 : Matrice de Hadamart (math√©maticien) d'ordre 4
Les propri√©t√©s de ces codes (1 1 1 1 ; 1 -1 1 -1 ; 1 1 -1 -1 ; 1 -1 -1 1) ne sont pas expliqu√©es ici. Nous nous conterons de v√©rifier leur bon fonctionnement.
1.3.1 Transmissions successives Chaque tableau ci-dessous repr√©sente une transmission qui est ind√©pendante des autres : elles ne se d√©roulent pas en m√™me temps. On v√©rifie qu‚Äôavec la mise en ≈ìuvre de ¬´ l‚Äô√©talement de spectre ¬ª, chaque transmission arrive bien √† destination avec le message qui avait √©t√© transmis. Le premier tableau est d√©j√† rempli en guise d‚Äôexemple. La m√©thode est la suivante :
A l‚Äô√©mission :
‚ñ† Chaque bit du message est multipli√© par un code d‚Äô√©talement (une ligne de la matrice) ‚ñ† Le r√©sultat de la multiplication est transmis
A la r√©ception :
‚ñ† Chaque symbole re√ßu est multipli√© par le m√™me code d‚Äô√©talement ‚ñ† Le message re√ßu est √©gal √† la somme des symboles, divis√© par le nombre de symbole

1

Message User 1

1

0

1

0

2 Utilisation code orthogonal User 1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1

3 Symboles transmis User 1 = (1) x (2) 1 -1 1 -1 0 0 0 0 1 -1 1 -1 0 0 0 0

‚Ä¶ transmission ‚Ä¶

4 Utilisation code orthogonal User 1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1

5

D√©codage = (3) x (4)

1111 0000 1111 0000

6

Message re√ßu (‚àë (5) / nbr_bits)

1

0

1

0

R√©aliser la transmission du message du User 2 et du User 3 dans les tableaux suivants :

|8

1‚Äô

Message User 2

0

1

0

1

2‚Äô Utilisation code orthogonal User 2 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1

3‚Äô Symboles transmis User 2 = (1‚Äô) x (2‚Äô) 0 0 0 0

‚Ä¶ transmission ‚Ä¶

4‚Äô Utilisation code orthogonal User 2 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1

5‚Äô

D√©codage = (3‚Äô) x (4‚Äô)

0000

6‚Äô Message re√ßu (‚àë (5‚Äô) / nbr_bits)

0

1‚Äô‚Äô

Message User 3

1

1

0

0

2‚Äô‚Äô Utilisation code orthogonal User 3 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1

3‚Äô‚Äô Symboles transmis User 3 = (1‚Äô‚Äô) x (2‚Äô‚Äô) 1 -1 -1 1

‚Ä¶ transmission ‚Ä¶

4‚Äô‚Äô

Utilisation code orthogonal User3

1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1

5‚Äô‚Äô

D√©codage = (3‚Äô‚Äô) x (4‚Äô‚Äô)

1111

6‚Äô‚Äô

Message re√ßu (‚àë (5‚Äô‚Äô) / nbr_bits)

1

1.3.2 Transmissions simultan√©es Les transmissions se d√©roulent maintenant simultan√©ment : les messages des User 1, User 2 et User 3 sont envoy√©s en m√™me temps sur la m√™me bande de fr√©quence. La premi√®re colonne du User 1 est d√©j√† remplie en guise d‚Äôexemple. La m√©thode est la suivante :
Dans l‚Äôair :
‚ñ† On additionne les symboles transmis par tous les User (1, 2, 3) : ligne 1‚Äô‚Äô‚Äô

Pour la r√©ception :
‚ñ† Chaque symbole re√ßu est multipli√© par le code d‚Äô√©talement du User ‚ñ† Le message re√ßu est √©gal √† la somme des symboles, divis√© par le nombre de symbole

Valider le fonctionnement pour la r√©ception des messages

1‚Äô‚Äô‚Äô

‚àë des symboles transmis ( 3 + 3‚Äô + 3‚Äô‚Äô )

2 -2 0 0

2‚Äô‚Äô‚Äô

Utilisation code orthogonal User 1

1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1

3‚Äô‚Äô‚Äô

D√©codage (1‚Äô‚Äô‚Äô) x (2‚Äô‚Äô‚Äô)

2200

4‚Äô‚Äô‚Äô

Message re√ßu User 1 (‚àë (3‚Äô‚Äô‚Äô)/ nbr_bits)

1

2‚Äô‚Äô‚Äô

Utilisation code orthogonal User 2

1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1

3‚Äô‚Äô‚Äô

D√©codage (1‚Äô‚Äô‚Äô) x (2‚Äô‚Äô‚Äô)

2 -2 0 0

4‚Äô‚Äô‚Äô

Message re√ßu User 2 (‚àë (3‚Äô‚Äô‚Äô)/ nbr_bits)

0

2‚Äô‚Äô‚Äô

Utilisation code orthogonal User 3

1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1

3‚Äô‚Äô‚Äô

D√©codage (1‚Äô‚Äô‚Äô) x (2‚Äô‚Äô‚Äô)

2 20 0

4‚Äô‚Äô‚Äô

Message re√ßu User 3 (‚àë (3‚Äô‚Äô‚Äô)/ nbr_bits)

1

1.3.3 Cas du protocole LoRa Le LoRa utilise une m√©thode d‚Äô√©talement de spectre qui n‚Äôest pas exactement celle que nous venons d‚Äô√©tudier. La finalit√© est cependant la m√™me : Pouvoir transmettre en m√™me temps, sur le m√™me canal. Le protocole LoRa utilise sept ¬´ codes d‚Äô√©talement ¬ª appel√©s Spreading Factor [ SF6, SF7, SF8, SF9, SF10, SF11 et SF12 ] qui lui permet d‚Äôavoir sept transmissions simultan√©es sur un m√™me canal.

|9

2 Transmission radio et propagation

2.1 Les unit√©s et d√©finitions
‚ñ† dB : Rapport entre deux puissances : Une att√©nuation est repr√©sent√©e par un nombre n√©gatif (-). Un gain est repr√©sent√© par un nombre positif (+).

Rapport de puissances en dB

Rapport de puissance

+ 3 dB

Multiplication par 2

- 3 dB

Division par 2

0 dB

Egalit√©

+ 10 dB

Multiplication par 10

- 10 dB

Division par 10

Tableau 2 : Comparaison entre les gains en dB et en proportion

‚ñ† dBi : Gain th√©orique d‚Äôune antenne ‚ñ† dBm : Puissance ramen√©e √† 1mW : 0 dBm correspond √† 1 mW.

En reprenant la d√©finition des dB remplir le tableau suivant :

Puissance en dBm

Puissance en mW

+ 3 dBm

- 3 dBm

+ 10 dBm

- 10 dBm

Tableau 3 : Comparaison entre les puissances en dB et en mW

Le Talkie-Walkie a une puissance d‚Äô√©mission de 2W. Quelle est la puissance d‚Äô√©mission exprim√©es en dBm ?

‚ñ† Sensibilit√© : Puissance minimale qu‚Äôest capable de d√©tecter un r√©cepteur ‚ñ† RSSI : Received Signal Strength Indication. ‚ñ† SNR : Signal over Noise Ratio

Un √©metteur transmet √† une puissance de 13dBm en utilisant une antenne dont le gain est de 2dBi. Les pertes dans l‚Äôair sont de 60 dB. L‚Äôantenne r√©ceptrice qui poss√®de un gain de 2dBi est reli√©e √† un r√©cepteur dont la sensibilit√© est de -80 dBm. Le signal pourra-t-il √™tre re√ßu ?

‚ñ† Le link Budget : C‚Äôest la quantit√© de puissance que nous pouvons perdre avant d‚Äôarriver au r√©cepteur, tout en conservant une transmission fonctionnelle. Autrement dit, c‚Äôest la puissance de l‚Äô√©metteur moins la sensibilit√© du r√©cepteur. Dans l‚Äôexemple pr√©c√©dent, le budget que nous avons √† disposition est de 93dB.

| 10

En LoRa, nous avons un Link Budget de 157 dB En LTE (4G), nous avons un Link Budget de 130 dB
Etude de la documentation d‚Äôun composant LoRa
Le RN2483 est le composant radiofr√©quence que nous utiliserons dans notre transmission LoRa. Voici quelques une de ses caract√©ristiques.
Figure 3 : Caract√©ristiques principales du composant radiofr√©quence utilis√© Reprenez la d√©finition du Link Budget et retrouver les 157 dB annonc√© dans cette documentation. En LoRa, plus le code d‚Äô√©talement est grand, plus on est capable d‚Äô√©mettre dans un milieu bruit√©. La figure ci-dessous pr√©sente les rapports signal sur bruit avec lesquels nous seront capable de r√©aliser une transmission, en fonction des Spreading Factor utilis√©s.
Figure 4 : Influence du Spreading Factor sur le SNR acceptable On remarque que pour un SF8, nous sommes capables d‚Äô√©mettre avec un SNR de -10 dB : On pourra transmettre malgr√© le fait que le bruit est 10 fois sup√©rieur au signal. On remarque que pour un SF12, nous sommes capables d‚Äô√©mettre avec un SNR de -20 dB : On pourra transmettre malgr√© le fait que le bruit est 100 fois sup√©rieur au signal !
| 11

Cependant, on remarque aussi que l‚Äôutilisation d‚Äôun Spreading Factor plus √©lev√©, augmente consid√©rablement le nombre de symbole √©mis (2√®me colonne du tableau). Comme nous le verrons plus tard, cela impactera √©videment le temps de transmission.
| 12

3 La couche physique LoRa
3.1 La modulation LoRa
Comme nous l‚Äôavons expliqu√© plus t√¥t, la modulation LoRa utilise l‚Äô√©talement de spectre pour transmettre ces informations. Mais au lieu d‚Äôutiliser des codes d‚Äô√©talement (CDMA), elle utilise une m√©thode appel√©e Chirp Spread Spectrum. La finalit√© est toujours la m√™me : Avoir plusieurs transmissions dans le m√™me canal. La cons√©quence sur le spectre est aussi la m√™me : cela provoque un √©talement du spectre.
3.1.1 La forme du symbole (Chirp) Le signal √©mis par la modulation LoRa est un symbole dont la forme de base est repr√©sent√©e cidessous. Son nom (Chirp) vient du fait que ce symbole est utilis√© dans la technologie Radar (Chirp : Compressed High Intensity Radar Pulse)
Figure 5 : Symbole de la modulation LoRa (source Wikip√©dia) La fr√©quence de d√©part est la fr√©quence centrale du canal moins la Bande Passante divis√©e par deux. La fr√©quence de fin est la fr√©quence centrale plus la Bande Passante divis√©e par deux :
‚ñ† La fr√©quence centrale est appel√©e le canal ‚ñ† La bande passante est la largeur de bande occup√©e autour du canal
On consid√®re une √©mission sur la fr√©quence centrale 868 Mhz avec une Bande Passante de 125 kHz. Donner la fr√©quence de d√©but et la fr√©quence de fin du sweep.
‚ñ† Fr√©quence de d√©but : ‚ñ† Fr√©quence de fin : Pour faciliter la repr√©sentation de ce symbole, on utilise plut√¥t un graphique Temps/Fr√©quence de la forme suivante :
| 13

Fr√©quence
868 062 500 Hz

Un symbole

Un symbole

868 000 000 Hz

867 937 500 Hz
Figure 6 : Forme du symbole de base (CHIRP)

Temps

En LoRa, chaque symbole repr√©sente un certain nombre de bits transmis. La r√®gle est la suivante :

Nombre de bits transmis dans un symbole = Spreading Factor

Par exemple, si la transmission utilise un Spreading Factor de 10 (SF10), alors un symbole repr√©sente 10 bits.

C‚Äôest-√†-dire qu‚Äô√† l‚Äô√©mission, les bits sont regroup√©s par paquet de SF bits, puis chaque paquet est repr√©sent√© par un symbole particulier parmi 2Ì†µÌ±ÜÌ†µÌ∞πformes de symboles possibles.

Sur la figure suivante, voici un exemple th√©orique d‚Äôune modulation en SF2 √† 868 Mhz, sur une bande passante de 125 kHz. Chaque symbole repr√©sente donc 2 bits.

Symbole 0 Bits ¬´ 00 ¬ª

Symbole 1 Bits ¬´ 01 ¬ª

Symbole 2 Bits ¬´ 10 ¬ª

Symbole 3 Bits ¬´ 11 ¬ª

868 062 500 Hz

125 kHz

868 000 000 Hz

867 937 500 Hz

Temps

Figure 7 : Symboles √©mis en Modulation LoRa (Cas th√©orique en SF2)
Exemple :
‚ñ† On consid√®re la suite binaire suivante : 0 1 0 1 1 1 0 0 0 1 1 0 0 1 0 0 0 1 1 0 1 ‚ñ† Le Spreading Factor utilis√© est SF10
Nous regroupons donc les bits par paquet de 10. Chaque paquet de 10 bits sera repr√©sent√© par un symbole (sweep) particulier. Il y a 1024 symboles diff√©rents pour coder les 1024 combinaisons binaires possibles (210).

| 14

01011100011001000110100110010001101

Envoi de 1 Chirp

Envoi de 1 Chirp Envoi de 1 Chirp

Transmission

Transmission

Transmission

Figure 8 : Emission des Chirp en LoRa
Avec un outils d‚Äôanalyse spectrale actif pendant l‚Äô√©mission LoRa d‚Äôun Device, on peut afficher les successions de symbole qui sont envoy√©s. Cette oscillogramme a √©t√© r√©alis√© √† l‚Äôaide d‚Äôun SDR (Software Digital Radio).

Figure 9 : Visualisation des Chirps LoRa r√©ellement √©mis pendant une transmission
3.1.2 Dur√©e d‚Äô√©mission d‚Äôun symbole En LoRa, la dur√©e d‚Äô√©mission de chaque symbole (Chirp) d√©pend du Spreading Factor utilis√©. Plus le SF est grand et plus le temps d‚Äô√©mission sera long. Pour une m√™me bande passante, le temps d‚Äô√©mission d‚Äôun symbole en SF8 est deux fois plus long que le temps d‚Äô√©mission d‚Äôun symbole en SF7. Ainsi de suite jusqu‚Äô√† SF12.
| 15

Fr√©quence
Fr√©quence haute

Temps d‚Äôun symbole √©mit en SF 12 Temps d‚Äôun symbole √©mit en SF 11 SF7 SF8
SF9

Fr√©quence centrale

SF10 SF11 SF12

Fr√©quence basse

Temps

Figure 10 : Temps d‚Äô√©mission d‚Äôun symbole (Chirp) en fonction du SF

En revanche, le temps d‚Äô√©mission d‚Äôun symbole est inversement proportionnel √† la bande passante :

Ì†µÌ±áÌ†µÌ±†

= Ì†µÌ∞µÌ†µÌ±éÌ†µÌ±õ2Ì†µÌ±ëÌ†µÌ†µÌ±ÜÌ†µÌ±§Ì∞πÌ†µÌ±ñÌ†µÌ±ëÌ†µÌ±°‚Ñé. Le d√©bit des symboles est donc de

1 Ì†µÌ±áÌ†µÌ±Ü

=

Ì†µÌ∞πÌ†µÌ±†

=

Ì†µÌ∞µÌ†µÌ±éÌ†µÌ±õÌ†µÌ±ëÌ†µÌ±§Ì†µÌ±ñÌ†µÌ±ëÌ†µÌ±°‚Ñé 2Ì†µÌ±ÜÌ†µÌ∞π

.

En

toute

logique,

plus

la

bande passant est √©lev√©, plus le d√©bit des symboles sera √©lev√©. Comme chaque symbole comprend

SF bit, on retrouve alors le d√©bit binaire :

Ì†µÌ∞µÌ†µÌ±éÌ†µÌ±õÌ†µÌ±ëÌ†µÌ±§Ì†µÌ±ñÌ†µÌ±ëÌ†µÌ±°‚Ñé

Ì†µÌ∞∑Ì†µÌ±è = Ì†µÌ±ÜÌ†µÌ∞π.

2Ì†µÌ±ÜÌ†µÌ∞π

Plus le Spreading Factor sera √©lev√©, plus le d√©bit binaire sera faible. Plus la Bande Passante sera √©lev√©e, plus le d√©bit binaire sera fort.

Exemple : D‚Äôapr√®s la formule du d√©bit binaire, trouver le d√©bit pour les deux cas suivants :

‚ñ† Cas 1 : Pour SF7 et 125 kHz > ‚ñ† Cas 2 : Pour SF12 et 125 kHz >

D√©bit = D√©bit =

3.2 Coding Rate
Le Coding Rate est un ratio qui augmentera le nombre de bits √† transmettre afin de r√©aliser de la d√©tection / correction d‚Äôerreur. Dans le cas d‚Äôun CR = 4 / 8, il y aura 8 bits transmis r√©ellement √† chaque fois que nous souhaitons transmettre 4 bits. Dans cette exemple, cela provoque une transmission d‚Äôun nombre de bit multipli√© par 2.

| 16

Figure 11 : Influence du Coding Rate sur le nombre de bits ajout√©

Si on reprend l‚Äôexemple pr√©c√©dent avec un CR de 4 / 5, nous avons une augmentation de 1.25 du nombre de bits √† transmettre. Redonner la d√©bit en prenant en compte le CR.

‚ñ† Cas 1 : Pour SF7 et 125 kHz > ‚ñ† Cas 2 : Pour SF12 et 125 kHz >

D√©bit = D√©bit =

La documentation du composant RN2483 donne les d√©bits en fonction du Spreading Factor, la Bande Passante et le Coding Rate. V√©rifier la coh√©rence du r√©sultat avec votre calcul pr√©c√©dent.

Figure 12 : D√©bit en fonction des param√®tres de la transmission LoRa
3.3 Utilisation du LoRa Calculator
Le logiciel ¬´ LoRa Calculator ¬ª est un petit ex√©cutable permettant de simuler une transmission LoRa en fonction des caract√©ristiques saisies : Canal, SF, CR, etc‚Ä¶ Il est t√©l√©chargeable √† l‚Äôadresse suivante : https://bit.ly/2TyloAh

| 17

Figure 13 : Le logiciel LoRa Calculator

En reprenant l‚Äôexemple pr√©c√©dent (SF7, Bande Passante 125 kHz, CR 4/5), v√©rifier les calculs du ¬´ Equivalent Bitrate ¬ª.

3.4 Time On Air
La norme LoRaWAN impose qu‚Äôun Device LoRa ne transmette pas plus de 1% du temps. Cela est repr√©sent√© par un Duty Cycle. Par exemple un Duty Cycle de 1% signifie que si j‚Äô√©met pendant 1, je ne dois plus √©mettre pendant 99, quel que soit l‚Äôunit√© de temps utilis√©e.

En reprenant les exemples pr√©c√©dents, quels sont les d√©bits moyens si on prend en compte le ¬´ Time On Air ¬ª ?

‚ñ† Cas 1 : Pour SF7 et 125 khz > ‚ñ† Cas 2 : Pour SF12 et 125 kHz >

D√©bit = D√©bit =

Dans le logiciel ¬´ LoRa Calculator ¬ª (onglet ¬´ Energy Profile ¬ª), nous pouvons estimer la dur√©e de vie d‚Äôune batterie. Nous prenons l‚Äôexemple d‚Äôun relev√© de temp√©rature dans un b√¢timent avec les caract√©ristiques suivantes :

| 18

‚ñ† SF, CR, Bande Passante, etc : Nous nous pla√ßons dans le cas 1 des exemples pr√©c√©dents. ‚ñ† Le relev√© de temp√©rature se fera toutes les 15 mins ‚ñ† La batterie est constitu√© de 3 petites piles b√¢tons [ AAA / LR03 ] 1.2V en s√©rie. Soit 3.6 V /
1000 mAh.
3.5 Mise en ≈ìuvre : LoRa en point √† point
Ce test sera r√©alis√© avec des modules LoRa RN2483 (Microchip) et une carte microcontr√¥leur ARDUINO.

Emetteur

R√©cepteur

UART UART

Figure 14 : Communication LoRa en Point √† Point

R√©aliser le c√¢blage de votre module RN2483 suivant le tableau suivant :

Connecteur Arduino Click Board RN2483

5V

5V

GND

GND

11

RX

10

TX

Tableau 4 : C√¢blage de l‚ÄôARDUINO et de la click Board RN2483

3.5.1 Utilisation de l‚ÄôIDE Arduino L‚Äôenvironnement Arduino est tr√®s simple. Nous allons r√©aliser un programme pour montrer son fonctionnement.

La connexion de la carte est effectu√©e √† l‚Äôaide d‚Äôun port USB qui √©mule une liaison s√©rie RS232. Il faut donc choisir le bon port : Arduino IDE > Outils > Port.

Pour cr√©er un nouveau programme (sketch) : Arduino IDE > Fichier > Nouveau

Il y a deux parties dans un sketch :

‚ñ† Une fonction setup() qui sera ex√©cut√©e qu‚Äôune seule fois au d√©marrage ‚ñ† Une fonction loop() qui sera ex√©cut√©e en boucle

Ecrire le code suivant :

| 19

void setup() { Serial.begin(9600); } void loop() { Serial.println("hello word"); } Compiler et T√©l√©verser : Croquis > T√©l√©verser Voir la sortie sur la liaison s√©rie : Outils > Moniteur S√©rie > Choisir la vitesse de transmission, ici 9600 bauds (en bas √† droite).
3.5.2 Validation du fonctionnement Deux bin√¥mes joueront le r√¥le d‚Äô√©metteur, tous les autres bin√¥mes seront en r√©cepteur.
R√©cup√©rer les programmes dans Moodle dans le dossier ¬´ RN2483-Arduino-Point2Point ¬ª. Installer la librairie RN2483 : Arduino IDE > Croquis > Inclure une biblioth√®que > Ajouter la biblioth√®que .zip. R√©partissez les r√¥les Emetteurs / R√©cepteurs et r√©cup√©rer le programme LoraBlinkerRX ou LoraBlinkerTX en fonction. Les 2 bin√¥mes en √©mission devront modifier le code du sketch Arduino pour transmettre des donn√©es sp√©cifiques afin de les diff√©rencier. [ loraSerial.println("radio tx 30"); ] Validez la r√©ception des donn√©es √©mises par les deux bin√¥mes qui transmettent des donn√©es. Ces donn√©es re√ßues sont √©crite √† 57600 bauds sur le moniteur s√©rie de l‚ÄôArduino. 3.5.3 Mise en valeur du Spreading Factor On s‚Äôaper√ßoit dans la manipulation pr√©c√©dente que les Devices LoRa re√ßoivent les donn√©es des deux √©metteurs. Nous allons conserver le m√™me canal d‚Äô√©mission (869,1 Mhz), mais un des deux √©metteurs va modifier son ¬´ Spreading Factor ¬ª. La salle sera donc s√©par√©e en deux groupes. ‚ñ† 1er groupe : Un √©metteur et au minimum un r√©cepteur utiliseront un SF7 ‚ñ† 2√®me groupe : Un √©metteur et au minimum un r√©cepteur utiliseront un SF8
Validez la r√©ception des donn√©es √©mises seulement pour le Spreading Factor que vous utilisez.
| 20

4 Le protocole LoRaWAN
Le LoRa est le type de modulation utilis√© entre deux Devices ou entre un Device et une Gateway. Lorsque nous parlons de l‚Äôensemble de la chaine de communication (Device, Gateway, Serveur) alors nous parlons de communication LoRaWAN. Nous allons voir l‚Äôarchitecture d‚Äôun r√©seau LoRaWAN, ainsi que les r√®gles de ce protocole.
4.1 Structure d‚Äôun r√©seau LoRaWAN
Nous retrouvons d‚Äôun c√¥t√© le Device LoRa qui transmet une donn√©e. Elle est r√©ceptionn√©e √† l‚Äôautre extr√©mit√© du r√©seau par un Utilisateur. La structure globale du r√©seau LoRaWAN peut √™tre repr√©sent√©e par la figure suivante :
Application Server Web

Internet

Internet

Network Server

Application Server

Devices
LoRa

Gateways

Figure 15 : Structure globale d'un r√©seau LORAWAN

Utilisateur

4.1.1 Les Devices LoRa Les Devices LoRa sont des syst√®mes √©lectroniques appartenant au monde de l‚ÄôIoT : Faible consommation, faible taille, faible puissance et faible taille.
Ils poss√®dent une radio LoRa permettant de joindre les Gateways. Les Gateways ne sont pas adress√©es sp√©cifiquement : toutes celles pr√©sentes dans la zone de couverture re√ßoivent les messages et les traitent.
4.1.2 Les Gateways LoRa Elles √©coutent sur tous les canaux, et sur tous les Spreading Factor. Lorsqu‚Äôune trame LoRa est re√ßue, elle transmet son contenu sur internet √† destination du Network Server qui a √©t√© configur√© dans la Gateway au pr√©alable.
Elle joue donc le r√¥le de passerelle entre une modulation LoRa, et une communication IP.

| 21

Device LoRa

Gateway

Application

LoRaWAN

Passerelle LoRa / Internet

Modulation LoRa

Modulation LoRa

Transmission Radio

Internet UDP / IP

Network Server
Application LoRaWAN Internet UDP / IP

Figure 16 : Le r√¥le de la Gateway LoRa
Chaque Gateway LoRa poss√®de un identifiant unique (EUI sur 64 bits).
4.1.3 Le Network Server Le Network Server re√ßoit les messages transmis par les Gateways et supprime les doublons (plusieurs Gateway peuvent avoir re√ßu le m√™me message). Les informations transmises au Network Server depuis les Devices LoRa sont authentifi√©s gr√¢ce √† une cl√© AES 128 bits appel√©e Network Session Key : NwkSKey. Nous parlons bien ici d‚Äôauthentification, et non pas de chiffrement comme nous le verrons plus tard.

Internet

Devices

Gateways

Network Server

Network Session Key (NwkSKey)

Authentification Figure 17 : Authentification entre le Device LoRa et le Network Server

4.1.4 Application Server Il est souvent sur le m√™me support physique que le Network Server. Il permet de dissocier les applications les unes des autres. Chaque application enregistre des Devices LoRa qui auront le droit

| 22

de stocker leurs donn√©es (Frame Payload). Les message transmis √† l‚Äôapplication server sont chiffr√©s gr√¢ce √† une cl√© AES 128 bits appel√©e Application Session Key : AppSKey.

Internet

Devices

Gateways

Network Server

Application Session Key (AppSKey) Chiffrement

Application Server

Figure 18: Chiffrement entre le Device LORA et l‚ÄôApplication Server
Le sch√©ma suivant r√©sume l‚Äôutilisation :
‚ñ† De la Network Session Key (NwkSKey) pour l‚Äôauthentification entre le Device LoRa et le Network Server
‚ñ† De l‚ÄôApplication Session Key (AppSKey) pour le chiffrement entre le Device LoRa et l‚ÄôApplication Server.

| 23

Internet

Network Server

Application Server

Devices

Gateways Network Session Key
Application Session Key

Figure 19 : Authentification et chiffrement en LoRaWan

4.1.5 Application / Web Serveur Cette application doit d‚Äôune part r√©cup√©rer les donn√©es de l‚ÄôApplication Serveur. Dans le cadre de ce cours, cela sera fait de deux fa√ßons :
‚ñ† Avec le protocole HTTP ‚ñ† Avec le protocole MQTT

Protocole MQTT ou HTTP
Flux Uplink

Application Server Web

Network Server

Application Server

Flux Downlink

Utilisateur

Figure 20 : Application / Web Server

| 24

Le flux habituel dans l‚ÄôIoT est le flux Uplink (flux montant), c‚Äôest-√†-dire l‚Äô√©mission de donn√©es des objets vers le serveur. Comme nous l‚Äôexpliquerons plus loin, en LoRaWAN il est aussi possible de transf√©rer des donn√©es aux Device LoRa par un flux Downlink (flux descendant).
D‚Äôautre part, l‚Äôapplication mettra √† disposition les donn√©es aux utilisateurs sous forme par exemple d‚Äôun serveur web, d‚Äôune base de donn√©es et d‚Äôune visualisation graphique.

4.1.6 Authentification avec le Network Server La Network Session Key (NwkSKey) sert √† l‚Äôauthentification entre le Device LoRa e le Network Server. Afin de r√©aliser cette authentification entre le Device et le Network Server, un champ MIC (Message Integrity Control) est rajout√© √† la trame. Il est calcul√© en fonction des donn√©es transmises et du NwkSkey. A la r√©ception, le m√™me calcul est effectu√©. Si les cl√©s sont √©quivalentes dans le Device et dans le Network Server alors les deux MIC calcul√©s doivent correspondre.

Device LoRa

Network Server

Donn√©es x chiffr√©es

NwkSkey x

NwkSkey x

MIC g√©n√©r√© R√©ception

Donn√©es x chiffr√©es MIC g√©n√©r√© Emission Trame √©mise

Donn√©es x chiffr√©es MIC g√©n√©r√© Emission Trame re√ßue

= Si MIC g√©n√©r√© Emission

MIC g√©n√©r√© R√©ception

Alors la trame est authentifi√©e

Figure 21 : Authentification d'un Device LoRa par le Network Server

4.1.7 Chiffrement des donn√©es vers l‚ÄôApplication Server L‚ÄôApplication Session Key (AppSKey) sert pour le chiffrement entre le Device LoRa et l‚ÄôApplication Server. Les donn√©es chiffr√©es seront alors d√©cod√©es √† la r√©ception sur l‚ÄôApplication Server s‚Äôil poss√®de la m√™me cl√©. Si on reprend le sch√©ma pr√©c√©dent, les ¬´ donn√©es x ¬ª sont chiffr√©es / d√©chiffr√©es par le processus suivant :

| 25

Device LoRa Donn√©es x non chiffr√©es
AppSKey Donn√©es x chiffr√©es

Application Server Donn√©es x non chiffr√©es
AppSKey Donn√©es x chiffr√©es

Figure 22 : Chiffrement des donn√©es par l'Application Session Key
4.1.8 Combinaison de l‚Äôauthentification et du chiffrement On peut maintenant repr√©senter sur le m√™me sch√©ma la construction de la trame LoRaWAN avec d‚Äôune part l‚Äôauthentification et d‚Äôautre part le chiffrement.

AppSKey

Donn√©es non chiffr√©es

Trame transmise =

Ent√™te

Donn√©es chiffr√©es MIC g√©n√©r√© en √©mission

NwkSKey
Figure 23 : Chiffrement, puis Authentification
4.2 Classes des Devices LoRaWAN
Les Devices LoRa sont class√©s en 3 cat√©gories (A, B, C) en fonction de leur consommation et de leur accessibilit√© en Downlink, c‚Äôest-√†-dire la facilit√© qu‚Äôun utilisateur aura √† transmettre une trame au Device LoRa.
4.2.1 Classe A (All) : Minimal power Application Tous les Devices LoRaWAN sont de classe A. Chaque Device peut transmettre (Uplink) √† la Gateway sans v√©rification de la disponibilit√© du r√©cepteur. Si la transmission √©choue, elle sera r√©√©mise apr√®s un certain temps. Cette transmission est suivie de 2 fen√™tres de r√©ception tr√®s courtes. La Gateway peut alors transmettre pendant le ¬´ RX Slot 1 ¬ª ou le ¬´ RX Slot 2 ¬ª, mais pas les deux.

| 26

Figure 24 : Slots de r√©ception pour un Device LoRa de classe A. Source de l‚Äôimage : https://zakelijkforum.kpn.com La dur√©e des fen√™tres doit √™tre au minimum la dur√©e de r√©ception d‚Äôun pr√©ambule. Un pr√©ambule dure 12.25 Tsymbole et d√©pend donc du Data Rate (DR : voir paragraphe 4.4.5 pour plus d‚Äôinformation sur le DR) . Lorsque qu‚Äôun pr√©ambule est d√©tect√©, le r√©cepteur doit rester actif jusqu‚Äô√† la fin de la transmission. Si la trame re√ßue pendant la premi√®re fen√™tre de r√©ception √©tait bien √† destination du Device LoRa, alors la deuxi√®me fen√™tre n‚Äôest pas ouverte. Premi√®re fen√™tre de r√©ception :
‚ñ† Le Slot RX1 est programm√© par d√©faut √† 1 seconde +/ 20 ¬µs apr√®s la fin de l‚Äô√©mission Uplink. ‚ñ† La fr√©quence et le Data Rate (DR) sont les m√™me que ceux choisis lors de la phase d‚Äô√©mission
(Uplink). Seconde fen√™tre de r√©ception :
‚ñ† Le Slot RX2 est programm√© par d√©faut √† 2 secondes +/ 20 ¬µs apr√®s la fin de l‚Äô√©mission Uplink. ‚ñ† La fr√©quence et le Data Rate (DR) sont configurables mais fixes.
Un Device LoRa qui est uniquement de classe A ne peut pas recevoir s‚Äôil n‚Äôa pas √©mis. Il n‚Äôest donc pas joignable facilement.
4.2.2 Classe B (Beacon) : Scheduled Receive Slot Les Devices de classe B ont le m√™me comportement que les Devices de classe A, mais d‚Äôautres fen√™tres de r√©ceptions sont programm√©es √† des p√©riodes pr√©cises. Afin de synchroniser les fen√™tres de r√©ception du Device LoRa, la Gateway doit transmettre des balises (Beacons) de fa√ßon r√©guli√®re.
| 27

Figure 25 : Slots de r√©ception pour un Device LoRa de classe B Source de l‚Äôimage : https://zakelijkforum.kpn.com
Un Device LoRa de classe B est joignable r√©guli√®rement sans qu‚Äôil soit n√©cessairement oblig√© d‚Äô√©mettre. En revanche, il consomme plus qu‚Äôun Device de classe A.
4.2.3 Classe C (Continuous) : Continuously Listening Les Devices de classe C ont des fen√™tres de r√©ception constamment ouvertes entre 2 Uplinks. Ces Devices consomment donc beaucoup plus.

Figure 26 : Slots de r√©ception pour un Device LoRa de classe C Source de l‚Äôimage : https://zakelijkforum.kpn.com

| 28

Un Device LoRa de classe C est joignable en permanence. En revanche, c‚Äôest la classe de Device qui est la plus √©nergivore.
4.2.4 Quelle Gateway pour les flux Downlink ? Nous avons donc vu que le fonctionnement classique du protocole LoRaWAN √©tait de r√©cup√©rer de l‚Äôinformation depuis le Device LoRa : C‚Äôest le flux Uplink. Dans le cas o√π l‚Äôutilisateur transmet des informations au Device LoRa (flux Downlink), on peut se demander quelle Gateway sera choisie pour transf√©rer les donn√©es au Device LoRa. En effet, l‚Äôendroit o√π est situ√© le Device LoRa n‚Äôest pas n√©cessairement connu √† l‚Äôavance.
La Gateway utilis√©e pour le Downlink est celle qui a re√ßu le dernier message du Device LoRa. Un message ne pourra jamais arriver √† destination d‚Äôun Device LoRa si celui-ci n‚Äôa jamais transmis, quel que soit sa classe A, B ou C.
4.3 Activation des Devices LoRa et s√©curit√©
En LoRaWAN, les trois √©l√©ments indispensables pour la communication sont le DevAddr pour l‚Äôindentification du Device, ainsi que deux cl√©s : le NwkSKey pour l‚Äôauthentification et l‚ÄôAppSKey pour le chiffrement. Deux m√©thodes sont possibles pour fournir ces informations √† la fois au Device LoRa et au serveur.
‚ñ† Activation By Personalization : APB ‚ñ† Over The Air Activation
4.3.1 ABP : Activation By Personalization C‚Äôest la plus simple des m√©thodes. C‚Äôest donc peut √™tre celle que nous avons tendance √† utiliser lors d‚Äôun test de prototype et d‚Äôune mise en place de communication LoRaWAN.
‚ñ† Le Device LoRa poss√®de d√©j√† le DevAddr, l‚ÄôAppSKey et le NwkSKey ‚ñ† Le Network server poss√®de d√©j√† le DevAddr et le NwkSKey ‚ñ† L‚Äôapplication serveur poss√®de d√©j√† le DevAddr et le AppSKey
En ABP, toutes les informations n√©cessaires √† la communication sont d√©j√† connues par le Device LoRa et par le Serveur.
| 29

Devices 1

DevAddr 1 NwkSkey 1 AppSKey 1
Devices 2
DevAddr 2 NwkSkey 2 AppSKey 2
Param√®tres programm√©s dans le composant

Network Server Application Server

DevAddr 1 NwkSkey 1 AppSKey 1

DevAddr 2 NwkSkey 2 AppSKey 2

Param√®tres stock√©s sur le serveur

Figure 27 : Param√©trage de DevAddr, NwkSKey et AppSKey

4.3.2 OTAA : Over The Air Activation : C‚Äôest la m√©thode qu‚Äôil faut privil√©gier car c‚Äôest celle qui est la plus s√©curis√©e. Le Device LoRa doit connaitre : le DevEUI, l‚ÄôAppEUI, et l‚ÄôAppkey. Le Network Server doit lui connaitre la m√™me Appkey.

Tous les √©l√©ments not√©s EUI (Extended Unique Identifier) sont toujours sur une taille de 64 bits.

Gr√¢ce √† ces informations de d√©part et une n√©gociation avec le Network Server (Join Request), le Device LoRa et le serveur vont g√©n√©rer les informations essentielles : DevAddr, NwkSKey et AppSKey.

DevEUI AppEUI AppKey

Join Request

DevAddr NwkSKey AppSKey

Figure 28 : Obtention du DevAddr, NwkSKey et AppSKey en OTAA
‚ñ† DevEUI : Unique Identifier pour le device LoRa (Equivalent √† une @MAC sur Ethernet). Certains Device LoRa ont d√©j√† un DevEUI fourni en usine.
‚ñ† AppEUI : Unique Identifier pour l‚Äôapplication server.

| 30

‚ñ† AppKey : AES 128 cl√© utilis√©e pour g√©n√©rer le MIC (Message Code Integrity) lors de la Join Resquest. Il est partag√© avec le Network server.
‚ñ† NwkSKey : Utilis√© pour l‚Äôauthentification avec le Network Server ‚ñ† AppSKey : Utilis√© pour le chiffrement des donn√©es
4.3.3 S√©curit√© Les cl√©s AES 128 bits permettent le chiffrement des informations transmises en LoRaWAN. Malgr√© ce chiffrement, une attaque connue en Wireless est celle du REPLAY. C‚Äôest-√†-dire que le Hacker enregistre des trames chiffr√©es circulant sur le r√©seau LoRa pour les r√©√©mettre plus tard. M√™me si le Hacker ne comprend pas le contenu (les trames sont chiffr√©es), les donn√©es qui sont transport√©es sont, elles, bien comprises par l‚ÄôApplication Server. Des actions peuvent donc √™tre r√©alis√©es simplement par mim√©tisme.

Devices LoRa

NwkSkey AppSKey
(1) Ecoute

Network Server

(1)

(2)

Application Server

NwkSkey

Hacker

AppSKey

(2) R√©√©mission

Figure 29 : Attaque par REPLAY
Pour √©viter cela, la trame LoRaWAN int√®gre un champ variable appel√© ¬´ Frame Counter ¬ª. Il s‚Äôagit d‚Äôun nombre num√©rotant la trame sur 16 ou 32 bits. L‚ÄôApplication Server acceptera une trame uniquement si le ¬´ Frame Counter ¬ª re√ßu est sup√©rieur au ¬´Frame Counter ¬ª pr√©c√©demment. Donc si le Hacker, retransmet la trame telle qu‚Äôelle, le ¬´ Frame Counter ¬ª sera √©quivalent, donc la trame sera refus√©e. Et comme la trame est chiffr√©e le Hacker n‚Äôa pas moyen de savoir comment modifier un champ de cette trame.
Cette s√©curit√© impl√©ment√©e par les ¬´ Frame Counter ¬ª est int√©ressante pour s‚Äôaffranchir d‚Äôune attaque par REPLAY, mais dans nos tests cela peut poser probl√®me. En effet, √† chaque fois que nous red√©marrons le microcontr√¥leur, notre ¬´ Frame Counter ¬ª revient √† z√©ro, alors que celui de l‚ÄôApplication Server continue de s‚Äôincr√©menter. Cela peut √™tre r√©solue par diff√©rentes mani√®res :
1. D√©sactivation du ¬´ Frame Counter Check ¬ª : Dans certain Application Server, cette option peut √™tre propos√©e. Bien s√ªr, il faudra garder en t√™te la faille de s√©curit√© que cela engendre.

| 31

Figure 30 : D√©sactivation du "Frame Counter Check" dans TTN
2. Utiliser l‚Äôauthentification par OTAA au lieu de ABP. En effet, √† chaque ouverture de session en OTAA, le ¬´ Frame Counter ¬ª est r√©initialis√© cot√© serveur.
3. Conserver la valeur du ¬´ Frame Counter ¬ª dans une m√©moire non volatile et r√©cup√©rer sa valeur au d√©marrage du Device LoRa.

4.4 La Trame LoRa / LoRaWAN
4.4.1 Les couches du protocole LoRaWAN Lorsque nous avons fait une communication en Point √† Point, nous avons simplement utilis√© la couche physique de la modulation LoRa. Lorsque nous souhaitons utiliser le protocole LoRaWAN, des couches protocolaires suppl√©mentaires se rajoutent.

Couche Application Couche Mac

Application LoRa Mac

Couche Physique

LoRa Modulation

Figure 31 : Les couches protocolaires du LoRaWAN
Chaque couche rajoute un service. Lors de l‚Äôenvoi de la trame, les donn√©es utilisateurs sont donc encapsul√©es dans chaque couche inf√©rieure jusqu‚Äô√† la transmission. Le d√©tail de l‚Äôensemble de la trame LoRaWAN par couche est d√©crit sur la figure Figure 32 :

| 32

Chiffrement des donn√©es utilisateur par l‚ÄôAppSkey

Donn√©es utilisateur N octets

AppSKey

Couche Application

Device Address Frame Control Frame Counter Frame Option Frame Port Frame Payload

4 octets

1 octet

2 octets 0 √† 15 octets 1 octet

N octets

Couche Mac
Couche Physique

MAC Header 1 octet
Preamble Header + Header CRC 20 bits

MAC Payload M octets
PHY Payload P octets

MIC 2 octets
CRC 2 octets

Figure 32 : Trame LORAWAN compl√®te par couche protocolaire
4.4.2 Couche Application La couche Application accueille les donn√©es de l‚Äôutilisateur. Avant de les encapsuler, elles sont chiffr√©es avec l‚ÄôAppSKey afin de s√©curiser la transaction.

Chiffrement des donn√©es utilisateur par l‚ÄôAppSkey

Donn√©es utilisateur N octets

AppSKey

Couche Application

Device Address Frame Control Frame Counter Frame Option Frame Port Frame Payload

4 octets

1 octet

2 octets

0 √† 15 octets 1 octet

N octets

Frame Header
Figure 33 : Trame LORA couche Applicative Un ensemble de champs nomm√© Frame Header permet de sp√©cifier le DevAddr, le Frame Control, le Frame Counter, et le Frame Option. Le Frame Port d√©pend du type d‚Äôapplication et sera choisi par l‚Äôutilisateur. Le Frame Payload sont les donn√©es chiffr√©es √† transmettre. Le nombre d‚Äôoctets maximum pouvant √™tre transmis (N octets) est donn√© dans le tableau suivant :

| 33

Data Rate Spreading Factor Bandwidth Max Frame Payload (Nombre N)

DR 0

SF12

125 KHz

51 octets

DR 1

SF11

125 KHz

51 octets

DR 2

SF10

125 KHz

51 octets

DR 3

SF9

125 KHz

115 octets

DR 4

SF8

125 KHz

222 octets

DR 5

SF7

125 KHz

222 octets

DR 6

SF7

250 KHz

222 octets

Tableau 5 : Taille maximum du Frame Payload en fonction du Data Rate

4.4.3 Couche LoRa MAC Cette trame est destin√©e au Network Server. Elle est authentifi√©e gr√¢ce au champ MIC (Message Integrity Protocol) selon la m√©thode expliqu√©e au paragraphe 4.1.6.

Le protocole LoRa MAC est compos√© de :

1. MAC Header : Version de protocole et type de message :

Type de Message

Description

000

Join-Request

001

Join-Accept

010

Unconfirmed Data Up

011

Unconfirmed Data Down

100

Confirmed Data Up

101

Confirmed Data Down

110

Rejoin-request

111

Proprietary

Tableau 6 : Les types de messages transmis en LoRaWAN

2. MAC Payload : Contient tout le protocole applicatif. 3. MIC : Message Integrity Code, pour l‚Äôauthentification de la trame.

Couche Mac

MAC Header 1 octet

MAC Payload M octets

Figure 34 : Trame LORA couche LORA MAC

MIC 2 octets

4.4.4 Couche physique : Modulation LoRa Le choix du moment d‚Äô√©mission des Devices LoRa se fait de fa√ßon simple : Lorsqu‚Äôun √©quipement doit √©mettre, il le fait sans contr√¥le et ne cherche pas √† savoir si le canal est libre. Si le paquet a √©t√© perdu, il le retransmettra simplement au bout d‚Äôun temps al√©atoire. La couche physique est repr√©sent√©e par l‚Äô√©mission de la trame suivante :

| 34

Couche Physique

Preamble Header + Header CRC ( Optionnel ) 20 bits

PHY Payload P octets

CRC 2 octets

Figure 35 : Trame LORA couche Physique
Le Pr√©ambule est repr√©sent√© par 8 symboles + 4.25. Le temps du Pr√©ambule est donc de 12.25 Tsymbole.
L'en-t√™te (Header optionnel) est seulement pr√©sent dans le mode de transmission par d√©faut (explicite), il est transmis avec un Coding Rate de 4/8. Il indique la taille des donn√©es, le Coding Rate pour le reste de la trame et il pr√©cise √©galement si un CRC sera pr√©sent en fin de trame.
Le PHY Payload contient toutes les informations de la Couche LoRa MAC.
Le CRC sert √† la d√©tection d‚Äôerreur de la trame LoRa.

4.4.5 Canaux et bandes de fr√©quences et Data Rate (DR) Le LoRa utilise des bandes de fr√©quences diff√©rentes suivant les r√©gions du monde. En Europe, la bande utilis√©e est celle des 868 Mhz [ De 863 Mhz √† 870 Mhz ]. Le LoRaWAN d√©finie les 8 canaux √† utiliser pour communiquer avec une Gateway suivant le tableau suivant :

Canaux Spreading Factor Bandwidth

868.1 Mhz De SF7 √† SF12

125 kHz

868.3 Mhz De SF7 √† SF12

125 kHz

868.3 Mhz

SF7

250 kHz

868.5 Mhz De SF7 √† SF12

125 kHz

867.1 Mhz De SF7 √† SF12

125 kHz

867.3 Mhz De SF7 √† SF12

125 kHz

867.5 Mhz De SF7 √† SF12

125 kHz

867.7 Mhz De SF7 √† SF12

125 kHz

867.9 Mhz De SF7 √† SF12

125 kHz

Tableau 7 : Canaux, SF et Bandwidth de notre Gateway LoRaWAN

Une Gateway LoRa √©coute donc sur 8 canaux simultan√©ment avec les 6 Spreading Factor diff√©rents, soit 48 combinaisons possibles.

Comme nous l‚Äôavons vu, le Spreading Factor a des cons√©quences sur le d√©bit de la transmission. Ces d√©bits sont not√©s DR (Data Rate) et sont normalis√©s de DR0 √† DR6 :

| 35

Data Rate Spreading Factor Bandwidth

DR 0

SF12

125 KHz

DR 1

SF11

125 KHz

DR 2

SF10

125 KHz

DR 3

SF9

125 KHz

DR 4

SF8

125 KHz

DR 5

SF7

125 KHz

DR 6

SF7

250 KHz

Tableau 8 : D√©nomination DR en fonction du SF et de la Bande Passante

4.4.6 Trame re√ßue et transmise par la Gateway LoRaWAN La Gateway re√ßoit d‚Äôun c√¥t√© un message radio modul√© en LoRa et transmet de l‚Äôautre c√¥t√© une trame IP √† destination du Network Server.

Device LoRa

Gateway Passerelle LoRa / Internet

Modulation LoRa

Internet UDP / IP

Transmission Radio

Network Server
Internet

Figure 36 : R√¥le de la Gateway LoRa
Cot√© interface Radio : La Gateway r√©ceptionne une trame LoRaWAN et extrait le PHY Payload. Celuici est cod√© au format ASCII en base 64 (voir le paragraphe 5.4.1). La Gateway extrait aussi toutes les informations utiles sur les caract√©ristiques de la r√©ception qui a eu lieu : SF, Bandwidth, RSSI, Time On Air‚Ä¶etc‚Ä¶
Cot√© interface r√©seau IP : La Gateway transmet l‚Äôensemble de ces informations dans un paquet IP (UDP) au Network Server. Les donn√©es transmises sont du texte en format JSON (voir paragraphe 4.4.7). La Gateway a donc bien un r√¥le de passerelle entre le protocole LoRa d‚Äôun c√¥t√© et un r√©seau IP de l‚Äôautre.

| 36

Gateway

‚ñ† R√©cup√©ration du PHY PAYLOAD en base 64 ‚ñ† R√©cup√©ration des caract√©ristiques de la transmission : : Canal, SF , CR ‚Ä¶

Modulation LORA

Donn√©es applicatives (format JSON)
{ "gw_id": "eui-b827ebfffeae26f5", "payload": "QNAPvA6Ax3ECqHk4C8hfzuA==", "lora": { "spreading_factor": 12, "bandwidth": 125, "air_time": 2465792000 }, "coding_rate": "4/5", "timestamp": "2019-01-20T13:37:46.017Z", "rssi": -105, "snr": -16.2, "dev_addr": "0EBC0FD0", "frequency": 867100000
}

UDP (Port dest : 1700 / Port source : 1700)

IP (IP dest : router.eu.thethings.network)

Ethernet

Transmission Radio LORA

Internet

Figure 37 : Passerelle (Gateway) LORAWAN

4.4.7 Le format JSON Le format JSON est un format texte compos√© d‚Äôune succession de couple nom/valeur. Dans l‚Äôexemple de la figure pr√©c√©dente, "gw_id" est un nom et "eui-b827ebfffeae26f5" est la valeur associ√©e. Dans cette exemple, la valeur est un string. Les objets sont d√©limit√©s par un des accolades { et }.

Une valeur peut √™tre :

‚ñ† Un string ‚ñ† Un nombre ‚ñ† Un objet ‚ñ† Un Boolean

exemple : exemple : exemple :

"coding_rate": "4/5" "spreading_factor": 12 "lora": { "spreading_factor": 12, "air_time": 2465792000 }

| 37

5 Mise en ≈ìuvre d‚Äôun r√©seau LoRaWAN
5.1 Les diff√©rents types de r√©seaux
Les r√©seaux LoRaWAN peuvent √™tre utilis√© suivant deux m√©thodes : ‚ñ† En utilisant les r√©seaux LoRaWAN op√©r√©s propos√©s par les op√©rateurs de t√©l√©coms ‚ñ† En utilisant votre propre r√©seau LoRaWAN priv√©
5.1.1 Les r√©seaux LoRaWAN op√©r√©s Ce sont des r√©seaux LoRaWAN propos√©s par les op√©rateurs. Par exemple Objenious (filiale de Bouyges) ou encore Orange. Dans le cas de l‚Äôutilisation des r√©seaux op√©r√©s, l‚Äôutilisateur a juste besoin de s‚Äôoccuper des Devices LoRa. Les Gateways, le Network Server et l‚ÄôApplication Server sont g√©r√©s par l‚Äôop√©rateur.
5.1.2 Les r√©seaux LoRaWAN priv√©s Chacun est libre de r√©aliser son propre r√©seau priv√© en impl√©mentant sa propre Gateway pour communiquer avec ses Devices LoRa. L‚Äôimpl√©mentation du Network Server et de l‚ÄôApplication Server peuvent alors √™tre envisag√©s de diff√©rentes fa√ßons. Network Server et Application serveur priv√©es : C‚Äôest le d√©veloppeur qui les mets en place. Dans certaines Gateways, une impl√©mentation de ces deux serveurs est d√©j√† propos√©e. Sinon il est possible de la mettre en place. Il existe des serveurs (Network et Application) open source, c‚Äôest le cas par exemple de LoRa Serveur [ www.loraserver.io ]
Une autre alternantive est : https://github.com/gotthardp/lorawan-server LoRaServer et lorawan-server sont deux applications Open Source.
Network Server et Application Server en ligne : Un certain nombre de Network Server et d‚ÄôApplication Server sont propos√©s. Ce sont des services payants ou avec des contreparties :
‚ñ† Loriot [ www.loriot.io ] ‚ñ† ResIoT [ www.resiot.io ] ‚ñ† The Things Network [ www.thethingsnetwork.org ] : C‚Äôest la solution que nous utiliserons.
5.1.3 Les zones de couvertures Les zones de couvertures des r√©seaux op√©r√©s sont mise √† jour par les op√©rateurs, celle d‚Äôobjenious est par exemple disponible ici : https://objenious.com/reseau/ Pour connaitre la zone de couverture de notre Gateway utilis√©e avec TTN, nous pouvons utiliser l‚Äôapplication TTN Mapper : https://ttnmapper.org/ . L‚Äôid√©e est de promener son Device LoRa associ√© √† un GPS dans la zone de couverture des Gateway qui nous entourent. A chaque trame re√ßue par le
| 38

Serveur, on note les coordonn√©es GPS du Device LoRa ainsi que la Gateway qui a transmis le message. Toutes ces informations sont alors retranscrites sur une carte.
5.2 The Things Network (TTN)
5.2.1 Pr√©sentation de TTN Pour la suite, nous utiliserons le Network Server et l‚ÄôApplication Server fourni par TTN : [www.thethingsnetwork.org]
TTN est gratuit et Open Source. En revanche, le fait d‚Äôutiliser TTN impose √† ceux qui enregistrent des Gateways de les mettre √† disposition √† tous les autres utilisateurs de TTN. L‚Äôobjectif est de r√©aliser un r√©seau global ouvert.

IP

Devices : Arduino RN2483

Gateways : EBDS

Network Server

Application Server

Figure 38 : Sch√©ma de notre application
5.2.2 Configuration de la Gateway A l‚Äôuniversit√©, nous avons deux Gateways LoRa (Marque EBDS). Elles sont toutes les deux situ√©es sur le Campus de Technolac. Une Gateway est √† l‚Äôint√©rieur du b√¢timent ISERAN et sert essentiellement pour les Travaux Pratiques et formations. L‚Äôautre est sur le toit du b√¢timent Chablais et est mise √† disposition du public via le service de TTN.
Les deux Gateway √©coutent sur tous les canaux et sur tous les Spreading Factor : SF7 > SF12.
‚ñ† L‚Äô@ IP de la Gateway LoRa √† l‚Äôuniversit√© (b√¢timent ISERAN) est 192.168.140.196 ‚ñ† Serveur DNS : 193.48.120.32 / 193.48.129.137 ‚ñ† Network Server (TTN) : 13.76.168.68 / router.eu.thethings.network ‚ñ† Port Upstream : 1700 / Port Downstream : 1700
5.2.3 Enregistrement des Gateways, Appplication et Devices La configuration de TTN se fait en ligne. La premi√®re op√©ration √† r√©aliser lorsqu‚Äôune nouvelle Gateway est d√©ploy√©e, c‚Äôest de l‚Äôenregistrer dans TTN.
‚ñ† Enregistrement d‚Äôune Gateway LoRa : TTN > Console > Gateway > register gateway

| 39

Figure 39 : Enregistrement d'une Gateway LoRa sur TTN ‚ñ† Enregistrement d‚Äôune application : TTN > Console > Application > add application
Figure 40 : Enregistrement d'une application sur TTN ‚ñ† Enregistrement des Devices LoRa dans l‚Äôapplication : Nom de l‚Äôapplication > register device
Figure 41 : Enregistrement des Devices LoRa dans une application 5.2.4 Configuration des Devices LoRa Lorsque nous avons enregistr√© des Devices LoRa dans TTN, nous devons choisir entre les deux modes d‚Äôauthentification. Dans un premier temps nous utiliserons le mode le plus simple qui est ABP. Nous g√©n√©rons dans TTN les DevAddr, NetwkSKey et AppSKey.
| 40

Figure 42 : Configuration des Devices LoRa en ABP dans TTN
5.3 Mise en application
Nous avons dans notre application 10 Devices LoRa d‚Äôenregistr√©s : aduino0 √† arduino9. Ils sont tous configur√©s en ABP. Les configurations des 10 Devices (DevAddr, NetwkSKey et AppSKey) sont not√©s en commentaire dans le code de vous allez r√©cup√©rer.
R√©cup√©rer le code Arduino ¬´ RN2483-Arduino-LORAWAN.ino ¬ª dans Moodle. Modifier votre configuration (DevAddr, NetwkSKey et AppSKey) en fonction de votre num√©ro de bin√¥me. V√©rifier que votre Device LoRa arrive bien √† transmettre des informations (Uplink) vers la Gateway, puis vers le Network Serveur de TTN (The Things Network).
5.4 Analyse des trames √©chang√©es
5.4.1 Utilisation de la base 64 Notre Gateway nous pr√©sente le Payload PHY en base64. L‚Äôexplication de la m√©thode de repr√©sentation en base 64 est fourni au travers d‚Äôun exemple : Le code hexad√©cimal 0x4869 repr√©sente nos donn√©es binaires que nous souhaitons transmettre en base 64.
1. On √©crit les donn√©es √† transmettre en binaire 0x4869 = 0100 1000 0110 1001
2. On regroupe les √©l√©ments binaires par des blocs de 6 bits. Le nombre de bloc de 6 bits doit √™tre un multiple de 4 (minimum 4 blocs). S‚Äôil manque des bits pour constituer un groupe de 6 bits, on rajoute des z√©ros.
| 41

Bloc de 6 bits

010010 000110 100100

On ajoute 00 pour avoir 6 bits dans le groupe

3. S‚Äôil manque des blocs pour faire un minimum de 4 blocs, des caract√®res sp√©ciaux seront ajout√©s.
4. Chaque groupe de 6 bits est traduit par le tableau suivant. (Source Wikip√©dia)

Figure 43 : Codage en base 64 010010 000110 100100

S

G

k

5. Si un bloc de 6 bits manque (ils doivent √™tre un multiple de 4), on rajoute un ou plusieurs compl√©ments (caract√®re ¬´ = ¬ª )

1er Bloc
010010

2√®me Bloc 3√®me Bloc
000110 100100

4√®me Bloc

S

G

k

=

R√©sultat : Le codage de 0x4869 en base 64 est ¬´ SGk= ¬ª

| 42

5.4.2 Int√©r√™t et inconv√©nient de la base 64 L‚Äôutilisation de la base 64 est un choix qui a √©t√© fait pour le protocole LoRa / LoRaWAN afin de rendre les donn√©es binaires lisibles. Le probl√®me du code ASCII c‚Äôest qu‚Äôil est compos√© d‚Äôun certain nombre de caract√®res non imprimables (EOF, CR, LF,‚Ä¶). Pour √©viter ces soucis, la base 64 ne comporte que 64 caract√®res imprimables (voir tableau ci-dessus).
La restriction √† 64 caract√®res a cependant un inconv√©nient, c‚Äôest que nous ne pouvons coder que 6 bits (26=64) au lieu de 8. La base 64 est donc moins efficace d‚Äôune fa√ßon g√©n√©rale.
Nous cherchons √† coder le code ASCII ¬´ AA ¬ª en base 64. Retrouver la d√©marche en montrant que le r√©sultat en base 64 est ¬´ QUE= ¬ª.

5.4.3 Uplink : Du Device LoRa au Network Server Le Network Server de TTN re√ßoit des trames IP en provenance de la Gateway. Comme nous l‚Äôavons vu pr√©c√©demment, un certain nombre d‚Äôinformations peuvent √™tre retrouv√©es avec cette trame (DevAddr, SF, Bandwidth, etc‚Ä¶) mais les donn√©es Applicatives sont bien s√ªr chiffr√©es (avec l‚ÄôAppkSKey). A ce niveau de r√©ception (sans connaitre l‚ÄôAppSKey), il n‚Äôest donc pas possible de comprendre la totalit√© du message re√ßu.
Imaginons que la trame IP re√ßue par le Network Server de TTN est la suivante :
{ "gw_id": "eui-b827ebfffeae26f6", "payload": "QNMaASYABwAP1obuUHQ=", "f_cnt": 7, "lora": { "spreading_factor": 7, "bandwidth": 125, "air_time": 46336000 }, "coding_rate": "4/5", "timestamp": "2019-03-05T14:00:42.448Z", "rssi": -82, "snr": 9, "dev_addr": "26011AD3", "frequency": 867300000
}
Le Network Server affiche donc les informations de la fa√ßon suivante :

Figure 44 : Trame r√©cup√©r√©e sur le ¬´ Network Server ¬ª de TTN Nous retrouvons bien les valeurs fournies par la Gateway :
‚ñ† timestamp ( √† 1 heure pr√®s en fonction du fuseau horaire),

| 43

‚ñ† frequency : 867,3 Mhz ‚ñ† modulation : Lora ‚ñ† Coding Rate : 4/5 ‚ñ† data Rate : SF 7 / 125 kHz (DR5) ‚ñ† air time : 46,3 ms
D‚Äôautres information proviennent de l‚Äôanalyse du Payload. Le Payload inscrit ici est le PHY Payload. Il y a donc une partie chiffr√©e (Frame Payload), mais les ent√™tes sont en claires (voir paragraphe 4.4.1). Ce PHY Payload est ¬´ QNMaASYABwAP1obuUHQ= ¬ª. Lorsque celui-ci est exprim√© en hexad√©cimal au lieu de la base 64, il vaut : ¬´ 40D31A01260007000FD686EE5074 ¬ª, comme le montre le Network Server de TTN.

Figure 45 : PHY Payload pr√©sent√© dans notre Network Server
Sa taille est bien de 14 octets (en hexad√©cimal) comme pr√©cis√© sur la Figure 44
Nous reprenons le format de la trame LoRaWAN vu √† la Figure 32. Nous pouvons alors retrouver tous les champs de toute la trame :

PHYPayload = 40D31A01260007000FD686EE5074

PHYPayload = MAC Header[1 octet] | MACPayload[..] | MIC[4 octets]

MAC Header

= 40 (Unconfirmed data up)

MACPayload

= D31A01260007000FD6

Message Integrity Code = 86EE5074

MACPayload = Frame Header | Frame Port | FramePayload )

Frame Header

= D31A0126000700

FPort

= 0F

FramePayload

= D6

Frame Header = DevAddr[4] | FCtrl[1] | FCnt[2] | FOpts[0..15]

DevAddr

= 26011AD3 (Big Endian)

FCtrl (Frame Control)

= 00 (No ACK, No ADR)

FCnt (Frame Counter)

= 0007 (Big Endian)

FOpts (Frame Option)

=

Vous pouvez v√©rifier l‚Äôensemble de ces informations gr√¢ce au d√©codeur de trame LoRaWAN (LoRaWAN packet decoder) : https://bit.ly/2szdXtv

| 44

Figure 46 : LoRaWAN packet decoder
5.4.4 Uplink : Du Network Server √† l‚ÄôApplication Server Nous reprenons l‚Äôexemple de la trame ci-dessus (Figure 45). Pour information, les cl√©s NwkSKey et AppSKey suivantes ont √©t√© utilis√©e :
‚ñ† NwkSKey : E3D90AFBC36AD479552EFEA2CDA937B9 ‚ñ† AppSKey : F0BC25E9E554B9646F208E1A8E3C7B24

Le Network Server a d√©cod√© l‚Äôensemble de la trame. Si le MIC est correct (authentification de la trame par le NwkSKey) alors le Network Server va passer le contenu du message chiffr√© (Frame Payload) √† l‚ÄôApplication Server. Dans notre cas le Frame Payload est (d‚Äôapr√®s le d√©codage effectu√© au chapitre pr√©c√©dent) :

FramePayload

= D6

D6 est le contenu chiffr√©, lorsqu‚Äôil est d√©chiffr√© avec l‚ÄôAppSkey on trouve 01. Vous pouvez v√©rifier l‚Äôensemble de ces informations gr√¢ce au d√©codeur de trame LoRaWAN : https://bit.ly/2szdXtv
A noter que l‚ÄôApplication Server recevra les donn√©es chiffr√©es seulement si le Device LoRa a bien √©t√© enregistr√©. On peut aussi v√©rifier ci-dessous que l‚ÄôApplication Serveur de TTN nous retourne bien un payload (Frame Payload) de 01.

Figure 47 : Trame r√©cup√©r√©e sur l‚ÄôApplication Server de TTN
{ "time": "2019-03-05T14:00:42.379279991Z", "frequency": 867.3, "modulation": "LORA", "data_rate": "SF7BW125", "coding_rate": "4/5", "gateways": [ { "gtw_id": "eui-b827ebfffeae26f6", "timestamp": 2447508531, "time": "", "channel": 4, "rssi": -82, "snr": 9, "latitude": 45.63647, "longitude": 5.8721523,

| 45

"location_source": "registry" } ]
5.4.5 Simulation d‚ÄôUplink dans l‚ÄôApplication Server Dans beaucoup de situations, nous souhaitons valider le fonctionnement de l‚ÄôApplication Server de TTN ou/et de notre propre Application. Il est donc tr√®s utile de pouvoir simuler l‚Äôenvoi d‚Äôune trame LoRa sur l‚ÄôApplication Server, sans que celle-ci soit r√©ellement √©mise par un Device LoRa. Pour cela, un outil existe dans les Settings de chaque Device enregistr√© dans TTN. Nous avons juste besoin de sp√©cifier le Frame Payload en clair en hexad√©cimal et le num√©ro de Port.
Figure 48 : Simulation d‚Äôune trame envoy√©e par un Device LoRa 5.4.6 Downlink : De l‚ÄôApplication Server au Device LoRa La communication LoRa est bidirectionnelle. Des donn√©es peuvent √™tre transmis au Device LoRa depuis l‚ÄôApplication Server. Depuis TTN, un outil existe dans les Settings de chaque Device enregistr√©. L‚Äôinterface est repr√©sent√©e ci-dessous.
Figure 49 : Transmission de donn√©es de l‚Äô ¬´ Application Server ¬ª jusqu‚Äôau Device LoRa ‚ñ† Replace scheduling Mode : Par d√©faut le Frame Payload transmis remplacera le Frame
Payload en attente (si il existe). Dans ce mode, un seul Frame Payload est planifi√©. ‚ñ† First scheduling Mode : Le Frame Payload est mis en file d‚Äôattente, en premi√®re position. ‚ñ† Last scheduling Mode : Le Payload est mis en file d‚Äôattente, en derni√®re position. Une demande de confirmation peut √™tre demand√©e au Device LoRa pour qu‚Äôil pr√©cise s‚Äôil a bien re√ßu les donn√©es. L‚Äôoption ¬´ confirmed ¬ª permet donc de sp√©cifier le type de trame dans le MAC Header (voir paragraphe 4.4.3) : ¬´ Confirmed Data Down ¬ª ou ¬´ Unconfirmed Data Down ¬ª dans notre cas.
| 46

6 La r√©cup√©ration des donn√©es sur notre propre Application
Nous utiliserons √† nouveau le Network Server et Application Server de The Things Network. Jusqu‚Äôici nous nous sommes content√© de v√©rifier que les donn√©es de l‚Äôutilisateur (Frame Payload) soient bien arriv√©es √† destination dans l‚ÄôApplication Server. Il faut maintenant les r√©cup√©rer avec notre propre Application qui aura pour r√¥le :
‚ñ† De stocker et traiter les donn√©es ‚ñ† De les mettre √† disposition de l‚Äôutilisateur (Serveur Web par exemple) ‚ñ† D‚Äôenvoyer des commandes de l‚Äôutilisateur aux Devices LoRa si besoin (Flux Downlink)

Internet

HTTP POST MQTT

Application Server Web

Network Server

Application Server

Devices Gateways
LORA
Figure 50 : Structure globale d‚Äôun r√©seau LORAWAN Nous allons voir deux m√©thodes pour communiquer entre notre application et TTN :
‚ñ† Le protocole HTTP POST ‚ñ† Le protocole MQTT

Utilisateur

6.1 R√©cup√©ration des donn√©es en HTTP POST dans l‚ÄôApplication
6.1.1 Pr√©sentation du protocole HTTP Dans le monde de l‚Äôinternet, le protocole HTTP est tr√®s utilis√© pour le dialogue entre un client et un serveur web. Classiquement, le client (un navigateur web par exemple) fait une requ√™te HTTP GET et le serveur lui retourne le contenu de la page web demand√©e.
Dans notre cas, la probl√©matique est diff√©rente, car le client doit modifier le contenu du serveur avec les donn√©es envoy√©es par le Device LORA. La requ√™te s‚Äôappelle HTTP POST. Son nom indique que le client va poster (et on pas r√©cup√©rer) des donn√©es.
L‚Äôutilisateur qui souhaite r√©ceptionner des donn√©es sur son serveur doit donc concevoir un serveur HTTP capable de traiter des requ√™tes HTTP POST [ requ√™te not√©e (1) sur la Figure 51 ] fournies par TTN. Dans cette configuration, TTN jouera le r√¥le de client, et notre application, le r√¥le de serveur.

| 47

The Things Network

Requ√™te (1 ) HTTP POST
[ Flux Uplink ]

Application

Requ√™te (2) HTTP POST
[ Flux Downlink ]

Figure 51 : Communication bidirectionnelle entre TTN et notre Application
A l‚Äôinverse l‚Äôutilisateur qui souhaite transmettre des donn√©es √† destination du Device LoRa (Downlink) doit √™tre capable de fournir une requ√™te HTTP POST [ requ√™te not√©e (2) sur la Figure 51 ] vers TTN. Dans cette configuration, TTN jouera le r√¥le de Serveur, et notre application, le r√¥le de client.
6.1.2 Fonctionnement d‚Äôun client et d‚Äôun serveur HTTP POST Afin de bien comprendre le fonctionnement des requ√™tes HTTP POST, nous allons proc√©der par √©tape. Le premier test que nous effectuerons sera decorr√©l√© de TTN. Le principe est le suivant :
‚ñ† Utilisation d‚Äôun serveur HTTP disponible sur le web, g√©rant les requ√™tes HTTP POST [ https://rbaskets.in/ ] ou [ https://beeceptor.com/ ] par exemple.
‚ñ† Utilisation d‚Äôun client HTTP √©mettant des requ√™tes HTTP POST : commande curl sous linux ou logiciel Postman [ www.getpostman.com ] sous windows par exemple.
Ce test nous permet de valider le fonctionnement d‚Äôun serveur HTTP POST et d‚Äôun client HTTP POST. Une fois que nous serons s√ªr de leur fonctionnement, nous les utiliserons avec TTN.

| 48

Client HTTP (POST)

Requ√™te HTTP POST

R√©ponse (contenu param√©trable)

Server HTTP (POST) [ https://rbaskets.in ]
Figure 52 : Validation d'un server HTTP POST et d‚Äôun client HTTP POST. 6.1.3 Test du serveur HTTP POST Nous utiliserons un serveur web propos√© par https://rbaskets.in/ .
Aller sur le site https://rbaskets.in/ et cr√©er un nouveau ¬´ Basket ¬ª : Zone o√π vous pourrez visualiser les requ√™tes qui ont √©t√© √©mises vers votre serveur. A partir de maintenant, toutes les requ√™tes dirig√©es vers l‚Äôadresse cr√©√©, seront trait√©es et s‚Äôafficheront. Dans le menu de configuration il est aussi possible de d√©finir le contenu de la r√©ponse qui sera fournie. D√©finir un format de r√©ponse pour les requ√™tes HTTP POST avec un body personnalis√©.
6.1.4 Test du client HTTP POST On peut r√©aliser le r√¥le du client de deux fa√ßons, soit en ligne de commande (la commande cURL s‚Äôex√©cute depuis un Terminal sous linux), soit avec le logiciel POSTMAN sous Windows.
Commande cURL : curl ‚ÄìX POST ‚Äìd ‚Äò‚Äôdonn√©es √† envoyer‚Äô‚Äô @DuServeurHTTP Logiciel Postman : New > Request > Cr√©er une requ√™te HTTP POST > Send V√©rifier que les requ√™tes HTTP POST sont bien r√©cup√©r√©es sur votre serveur cr√©e pr√©c√©demment.
6.1.5 R√©cup√©rer des donn√©es sur notre Application avec HTTP POST Maintenant que nous avons un serveur HTTP (POST) fonctionnel, nous allons configurer TTN pour jouer le r√¥le du client et pour qu‚Äôil envoie des requ√™tes HTTP POST vers notre Serveur d√®s qu‚Äôune donn√©e d‚Äôun Device LoRa est disponible. Nous g√©rons donc ici le flux Uplink.

| 49

Requ√™te HTTP POST

The Things Network (Client)
La requ√™te contient le Frame Payload d√©chiffr√©e √† transmettre √† l‚ÄôApplication

Server HTTP (POST) [ https://rbaskets.in ]
Figure 53 : R√©cup√©ration des donn√©es sur notre Application Dans TTN, nous int√©grons un bloc appel√© ¬´ HTTP Integration ¬ª permettant de jouer le r√¥le de client, c‚Äôest-√†-dire d‚Äôenvoyer des requ√™tes HTTP POST √† destination de notre nouveau Serveur HTTP. L‚Äôint√©gration se faire √† partir de TTN > Console > Application > Nom_de_votre_application > Integration.

Figure 54 : Ajout d'un client HTTP POST dans TTN
Pour valider le fonctionnement de notre architecture, nous pouvons soit :
‚ñ† Envoyer une trame depuis un Device LoRa vers TTN ‚ñ† Simuler l‚Äôenvoi d‚Äôune trame d‚Äôun Device LoRa vers TTN (gr√¢ce √† l‚Äôoutil propos√© par TTN vu
paragraphe 5.4.5)
Dans les deux cas, voici un exemple de requ√™te POST re√ßue sur notre serveur HTTP :
{ "app_id": "test_app_lorawan_sylvainmontagny", "dev_id": "stm32lorawan_1", "hardware_serial": "0056A......F49877", "port": 1, "counter": 0, "payload_raw": "qg==", "metadata": {
| 50

"time": "2019-01-24T15:24:37.03499298Z" }, "downlink_url":"https://integrations.thethingsnetwork.org/ttn-
eu/api/v2/down/test_app_lorawan_sylvainmontagny/rbaskets?key=ttn-accountv2.........................8ypjj7ZnL3KieQ"
}
Comme nous pouvons le voir, le contenu fourni √† notre serveur est format√© en JSON (voir paragraphe 0). Voici quelques compl√©ments d‚Äôinformation :
‚ñ† payload_raw : Frame Payload d√©chiffr√©, c‚Äôest donc les donn√©es en clairs dans la base 64. ‚ñ† downlink_url : URL du serveur HTTP POST qui serviront √† transmettre des donn√©es au Device
LoRa (flux Downlink)
6.1.1 Envoyer des donn√©es depuis notre Application avec HTTP POST Lorsque nous avons ajout√© le bloc ¬´ HTTP Integration ¬ª au paragraphe pr√©c√©dent, nous avons aussi implicitement activ√© la fonctionnalit√© que TTN soit pr√™t √† recevoir et √† traiter les requ√™tes HTTP POST. La seule information qu‚Äôil nous manque est l‚Äôadresse du server HTTP vers lequel il faut √©mettre les requ√™tes. Si on observe la trame re√ßue pr√©c√©demment en provenance de TTN , on s‚Äôaper√ßoit que dans la trame JSON re√ßu, une URL (downlink_url) est sp√©cifi√©e :
"downlink_url":":"https://integrations.thethingsnetwork.org/ttn-
eu/api/v2/down/test_app_lorawan_sylvainmontagny/rbaskets?key=ttn-accountv2.........................8ypjj7ZnL3KieQ"
C‚Äôest cette URL que nous devrons utiliser. Nous allons nous placer dans la configuration suivante :
The Things Network (Serveur)
Requ√™te HTTP POST vers serveur TTN : ¬´ downlink_url ¬ª
https://integrations.thethingsnetwor.......Uaeb8ypKieQ
Contenu de la requ√™te : ‚ñ† "dev_id": "Identidiant_De_Votre_Device", ‚ñ† "payload_raw": "aGVsbG8="
POSTMAN (Client HTTP POST)
Figure 55 : Envoi de donn√©es √† partir de notre Application Comme pr√©c√©demment, on peut r√©aliser le r√¥le du client de deux fa√ßons : soit en ligne de commande (la commande cURL s‚Äôex√©cute depuis un Terminal sous linux), soit avec le logiciel POSTMAN.
Commande cURL : curl ‚ÄìX POST ‚Äìdata ‚Äò{ "dev_id" :" Identidiant_De_Votre_Device ", "payload_raw" : "AQE=" }‚Äô @DuServeurHTTP Logiciel Postman : New > Request > HTTP POST , puis Body > Raw > JSON :
| 51

{ "dev_id": "YourDeviceID", "payload_raw": "aGVsbG8="
}
Vous devez envoyer le texte (payload_raw) en base 64. Dans l‚Äôexemple ci-dessus ¬´ aGVsbG8= ¬ª correspond √† la chaine de caract√®re ¬´ hello ¬ª Vous pouvez utiliser les nombreux encodeur/decodeur en ligne pour vous aider. Le texte doit s‚Äôafficher sur votre moniteur s√©rie Arduino dans le cadre de notre d√©monstrateur sur Arduino.
6.2 R√©cup√©ration des donn√©es avec MQTT dans l‚ÄôApplication
6.2.1 Pr√©sentation du protocole MQTT MQTT est un protocole l√©ger qui permet de s‚Äôabonner √† des flux de donn√©es. Plut√¥t que l‚Äôarchitecture Client / Serveur classique qui fonctionne avec des Requ√™tes / R√©ponses, MQTT est bas√© sur un mod√®le Publisher / Subscriber. La diff√©rence est importante, car cela √©vite d'avoir √† demander (Requ√™te) des donn√©es dont on n'a aucune id√©e du moment o√π elles vont arriver. Une donn√©e sera donc directement transmise au Subscriber d√®s lors que celle-ci a √©t√© re√ßue dans le Broker (serveur central).
Broker

Client Publisher 1
Client Publisher 2

Topic Temp√©rature
Topic Humidit√©

Client Subscriber

Figure 56 : Mod√®le Publisher / Subscriber du protocole MQTT
Pour recevoir les donn√©es appartenant √† un Topic, un Subscriber doit souscrire (comme son nom l'indique) au pr√©alable sur ce Topic.
MQTT est un protocole qui repose sur TCP. L'encapsulation des trames sur le r√©seau est donc la suivante :

| 52

Couche Application Transport R√©seau

MQTT TCP IP

Figure 57 : Protocoles utilis√©s pour la communication avec MQTT On peut le v√©rifier par une capture de trame sur Wireshark.

Figure 58 : Capture d'une trame MQTT avec Wireshark
On peut noter que le port TCP utilis√© pour le protocole MQTT (non chiffr√©) est le 1883.
Les Publishers et les Subscribers n‚Äôont pas besoin de se connaitre. Les Publishers et les Subscribers ne sont pas oblig√© de s‚Äôex√©cuter en m√™me temps.
6.2.2 Connexion au Broker MQTT Nous nous int√©resserons essentiellement aux options de connexion qui permettront de g√©rer la Qualit√© de Service (QoS). Pour se connecter, un client MQTT envoie deux informations importantes au Broker :
keepAlive : C'est la p√©riode la plus longue pendant laquelle le client Publisher ou Subscriber pourra rester silencieux. Au-del√†, il sera consid√©r√© comme d√©connect√©.
cleanSession : Lorsque le Client et le Broker sont momentan√©ment d√©connect√©s (au-del√† du keepAlive annonc√©), on peut donc se poser la question de savoir ce qu'il se passera lorsque le client sera √† nouveau connect√© :
‚ñ† Si la connexion √©tait non persistante (cleanSession = True) alors les messages non transmis sont perdus. Quel que soit le niveau de QoS (Quality of Service).
‚ñ† Si la connexion √©tait persistante (cleanSession = False) alors les messages non transmis seront √©ventuellement r√©√©mis, en fonction du niveau de QoS. Voir le chapitre 6.2.4.
6.2.3 Qualit√© de Service au cours d'une m√™me connexion A partir du moment o√π le Client se connecte au Broker, il est possible de choisir un niveau de fiabilit√© des transactions. Le Publisher fiabilise l'√©mission de ces messages vers le Broker, et le Subscriber fiabilise la r√©ception des messages en provenance du Broker. Une parle ici du cas d'une m√™me connexion, c‚Äôest-√†-dire entre le moment ou le Client se connecte, et le moment o√π :
‚ñ† Soit il se d√©connecte explicitement (Close connexion) ‚ñ† Soit il n'a rien √©mis, ni fait signe de vie pendant le temps ''keepAlive''

| 53

Lors d'une m√™me connexion la Qualit√© de Service (QoS) qui est mise en ≈ìuvre d√©pend uniquement de la valeur du QoS selon les valeurs suivantes :
QoS 0 ''At most once'' (au plus une fois). : Le premier niveau de qualit√© est "sans acquittement". Le Publisher envoie un message une seule fois au Broker et le Broker ne transmet ce message qu'une seule fois aux Subscribers. Ce m√©canise ne garantit pas la bonne r√©ception des messages MQTT.
QoS 1 ''At least once'' (au moins une fois) : Le deuxi√®me niveau de qualit√© est "avec acquittement". Le Publisher envoie un message au Broker et attends sa confirmation. De la m√™me fa√ßon le Broker envoie un message √† ces Subscriber et attends leurs confirmations. Ce m√©canisme garantit la r√©ception des message MQTT.
Cependant, si les acquittements n‚Äôarrivent pas en temps voulu, ou s‚Äôils se perdent, la r√©√©mission du message d'origine peut engendrer une duplication du message. Il peut donc √™tre re√ßu plusieurs fois.
QoS 2 ''Exactly once'' (exactement une fois) : Le troisi√®me niveau de qualit√© est "garanti une seule fois". Le Publisher envoie un message au Broker et attends sa confirmation. Le Publisher donne alors l‚Äôordre de diffuser le message et attends une confirmation. Ce m√©canisme garantit que quel que soit le nombre de tentatives de r√©emission, le message ne sera d√©livr√© qu'une seule fois.
La Figure 59 montre les trames √©mises pour chaque niveau de QoS.

QoS 0 ''Au plus une fois''
PUBLISH
Message supprim√© apr√®s envoi
QoS 0 ''Au moins une fois''
PUBLISH
PUBLICH Ack
Message enregistr√© Survie √† une perte de connexion Duplications possibles

Broker

QoS 0 ''Au moins une fois''
PUBLISH
PUBLISH Receive
PUBLISH Release
PUBLISH Complete
Message enregistr√© Survie √† une perte de connexion Pas de duplication

Figure 59 : Qualit√© de Service en MQTT
La Figure 60 repr√©sentes les 3 captures de trames sur Wireshark repr√©sentant les 3 QoS (1, 2 et 3) que nous venons d'expliquer.

| 54

Figure 60 : Capture de trame avec QoS = 0, puis QoS = 1, puis QoS = 2

6.2.4 Qualit√© de Service apr√®s une reconnexion La question que nous nous posons et de savoir ce que deviennent les messages publi√©s sur le Broker lorsqu'un ou plusieurs Subscribers sont momentan√©ment injoignables. Il est possible de conserver les messages qui ont √©t√© publi√©s sur le Broker afin de les retransmettre lors de la prochaine connexion. Cette possibilit√© de sauvegarde doit √™tre activ√©e √† l'ouverture de connexion gr√¢ce au flag cleanSession = 0. La connexion sera alors persistante, c‚Äôest-√†-dire que le Broker enregistre tous les messages qu'il n'a pas r√©ussi √† diffuser au Subscriber.

Le Tableau 9 r√©sume l'effet du flag cleanSession et du QoS.

Clean Session Flag Subscriber QoS Publisher QoS

Comportement

True ( = 1)

0/1/2

0/1/2

Messages perdus

False ( = 0 )

0

0 / 1 /2

Messages perdus

False (= 0 )

0 /1 / 2

0

Messages perdus

False (= 0 )

1/2

1/2

Tous les messages sont retransmis

Tableau 9 : Qualit√© de Service en fonction de la valeur du QoS et du flag cleanSession

6.2.5 Les Topics du protocole MQTT Les cha√Ænes d√©crivant un sujet forment une arborescence en utilisant la barre oblique "/" comme caract√®re de s√©paration. La Figure 61 et le Tableau 10 donne un exemple d'organisation de Topic.

Niveau 1

Maison

Niveau 2

Chambre

Salon

Niveau 3

Temperature

Humidite

Bruit

Figure 61 : Exemple de hi√©rarchie de Topic MQTT

Temperature

| 55

Nom du Topic

D√©tail du Topic

Maison/Chambre/Temperature La temp√©rature de la chambre de la maison

Maison/Chambre/Bruit

Le bruit de la chambre de la maison

Maison/Salon/Temperature

La temp√©rature du Salon de la maison

Tableau 10 : Exemple de Topic

Un client peut s'abonner (ou se d√©sabonner) √† plusieurs branches de l'arborescence √† l'aide de "jokers" englobant plusieurs Topics. Deux caract√®res "jokers" existent :

‚ñ† Le signe plus "+" remplace n'importe quelle chaine de caract√®re sur le niveau o√π il est plac√©. ‚ñ† Le di√®se "#" remplace n'importe quelle chaine de caract√®re sur tous les niveaux suivants. Il
est obligatoirement plac√© √† la fin.

Nom du Topic
Maison/+/Temperature Maison/Chambre/#

D√©tail du Topic
Les temp√©ratures de toutes les pi√®ces de la maison La temp√©rature, l'humidit√© et le bruit de la chambre de la maison.
Tableau 11 : Exemple de Topic

6.2.6 Mise en place d‚Äôun Broker MQTT Afin de bien comprendre le fonctionnement du protocole de MQTT, on r√©alise des tests ind√©pendamment de TTN. Nous allons mettre en place :
‚ñ† Un Broker : Mosquitto https://test.mosquitto.org/ ‚ñ† Un client Publisher : MQTT Box sur Windows ‚ñ† Un client Subscriber : MQTT Box sur Windows

MQTT Client (Publisher) Publish
BROKER (Mosquitto) Subscribe
MQTT Client (Subscriber) Figure 62 : Test du protocole MQTT

| 56

Le Broker MQTT est commun √† tout le monde. Nous pouvons soit le r√©aliser nous-m√™me, soit utiliser un Broker MQTT public de test. Nous utiliserons le Broker de test de Mosquitto disponible sur https://test.mosquitto.org/. D‚Äôautres sont √©ventuellement disponibles en cas de probl√®me, par exemple : http://www.mqtt-dashboard.com/

Si nous d√©cidions de le r√©aliser nous-m√™me √† l‚Äôaide d‚Äôune Raspberry Pi (par exemple). L‚Äôinstallation se ferait en deux lignes de commande :

‚ñ† apt-get install mosquito ‚ñ† sudo systemctl start mosquitto.service

// Installation // Lancement du service

Il est n√©cessaire d‚Äôinstaller mosquitto-clients si on souhaite que le Raspberry PI joue aussi le r√¥le de client, ce qui n‚Äôest pas notre cas.

6.2.7 Mise en place d‚Äôun Publisher et d‚Äôun Subscriber MQTT Lancer le logiciel MQTTBox.
MQTTBox > Create MQTT Client.
Dans ce client les seuls champs indispensables sont :
‚ñ† Protocol : MQTT /TCP ‚ñ† Host : test.mosquitto.org

Figure 63 : Configuration d'un Client MQTT dans MQTT Box Tester l‚Äôenvoi et la r√©ception sur les Topics de votre choix.
6.2.8 R√©cup√©rer des donn√©es sur notre Application avec MQTT La r√©cup√©ration des donn√©es fait r√©f√©rence au flux Uplink. Dans ce cas :
‚ñ† TTN joue le r√¥le de client Publisher ‚ñ† TTN joue aussi le r√¥le de Broker ‚ñ† Notre application joue le r√¥le de Subscriber
Nous pouvons donc repr√©senter l‚Äôapplication globale par le sch√©ma suivant :

| 57

The Things Network (Network Server)
Publish (1 ) [ Flux Uplink ]
The Things Network (Application Server) BROKER
Subscribe (2 ) [ Flux Uplink ]
Application
Figure 64 : Publisher et Subscriber dans en MQTT avec TTN ‚ñ† La publication est repr√©sent√©e par la trame MQTT (1) ‚ñ† La souscription est repr√©sent√©e par la trame MQTT (2) Le client Publisher √©tant r√©alis√© par TTN, il est d√©j√† configur√©. Il nous reste √† configure le client Subscriber. Nous utiliserons √† nouveau MQTT Box mais cette fois avec la configuration suivante : ‚ñ† Protocol : mqtt / tcp ‚ñ† Host : C‚Äôest l‚Äô@IP du Broker vers lequel il faut se connecter. Dans notre cas il s‚Äôagit de celui
de TTN dont l‚Äôadresse est : eu.thethings.network ‚ñ† Username : La connexion vers le broker MQTT est soumis √† une authentification Username
/ Password. Dans notre cas le Username correspond au nom de notre application, c‚Äôest-√†dire : seminaire_lorawan. Si vous avez choisi une autre application,il faut bien mettre la votre. ‚ñ† Password : Le Password est nomm√© ¬´ Access Key ¬ª par TTN. Elle vous sera donn√©e par l‚Äôenseignant dans le cadre de ce test. Si vous avez enregistr√© votre propre application, vous trouverez l‚ÄôAccess Key dans : TTN > Application > Nom_de_votre_application > Overview.
Figure 65 : Access Keys de l'application dans TTN
| 58

Figure 66 : Configuration du Client dans MQTT Box
Le client MQTT √©tant configur√©, il est maintenant capable de se connecter au Broker. Il reste donc √† d√©finir le fait que le client sera Subscriber. Les informations que recevra le Subscriber d√©pendent du Topic auquel nous souscrivons. Voici les Topic disponibles sur le Broker de TTN :
‚ñ† <AppID> correspond au nom de votre Application ‚ñ† <DevID> correspond au nom de votre Device LoRa

D√©tail du Topic

Nom du Topic

[Donn√©es] Flux Uplink

<AppID>/devices/<DevID>/up

[Donn√©es] Flux Downlink

<AppID>/devices/<DevID>/down

[Activation Events] Activation d'un Device

<AppID>/devices/<DevID>/events/activations

[Management Events] Cr√©ation d'un Device

<AppID>/devices/<DevID>/events/create

[Management Events] Update d'un Device

<AppID>/devices/<DevID>/events/update

[Management Events] Suppression d'un Device <AppID>/devices/<DevID>/events/delete

[Downlink Events ] Message programm√©

<AppID>/devices/<DevID>/events/down/scheduled

[Downlink Events ] Message envoy√©

<AppID>/devices/<DevID>/events/down/sent

[Erreurs] Uplink erreurs

<AppID>/devices/<DevID>/events/up/errors

[Erreurs] Downlink erreurs

<AppID>/devices/<DevID>/events/down/errors

[Erreurs] Activations erreurs

<AppID>/devices/<DevID>/events/activations/errors

Tableau 12 : Topics enregistr√©s dans TTN

Dans un premier temps nous souscrivons au Topic : +/devices/+/up. Cela signifie que nous souscrivons √† tous les Devices LoRa de toutes nos applications pour le flux Uplink.

Figure 67 : Configuration du Subscriber Les √©l√©ments √©mis par le Broker seront alors affich√©s dans MQTTBox. La
| 59

Figure 68 : Trame LoRaWAN re√ßu sur le Subscriber MQTT Ces donn√©es sont √©crites en JSON, nous pouvons les remettre en forme :
{ "applicationID":"3", "applicationName":"myApplication", "deviceName":"arduino0", "devEUI":"0056xxxxxxxxx877", "txInfo": { "frequency":868500000, "dr":5 }, "adr":false, "fCnt":792, "fPort":15, "data":"SGVsbG8="
} Le "Frame Payload" d√©chiffr√© est fourni dans le champ "data" en base 64. La valeur fournie par "data":"SGVsbG8=" correspond bien √† la chaine de caract√®re "hello" que nous avons √©mise avec le Device LoRa.
6.2.9 Envoyer des donn√©es depuis notre Application avec MQTT L‚Äôenvoi des donn√©es fait r√©f√©rence au flux Downlink. Dans ce cas :
‚ñ† Notre application joue le r√¥le de Publisher ‚ñ† TTN joue le r√¥le de Broker ‚ñ† TTN joue aussi le r√¥le de client Subscriber
| 60

The Things Network (Network Server)
Subscribe (4) [ Flux Downlink ]
The Things Network (Application Server) BROKER Publish (3) [ Flux Downlink ]
Application
‚ñ† La publication est repr√©sent√©e par la trame MQTT (3) ‚ñ† La souscription est repr√©sent√©e par la trame MQTT (4) Le client Subscriber √©tant r√©alis√© par TTN, il est d√©j√† configur√©. Il nous reste √† configure le client Subscriber. Nous utiliserons √† nouveau MQTT Box. Le r√¥le de client dans MQTT Box a √©t√© faite au paragraphe 6.2.8. Il nous reste simplement √† ajouter le r√¥le de Publisher. La configuration est la suivante : ‚ñ† Topic du Subscriber : seminaire_lorawan/devices/arduino0/down o√π seminaire_lorawan
est √† remplacer par le nom de votre application, et arduino0 par le nom du Device LoRa vers lequel vous souhaitez envoy√© une donn√©e. (Voir chapitre 6.2.8 pour comprendre les Topics) ‚ñ† Le Payload doit √™tre au format JSON. L‚Äôexemple suivant envoie ¬´hello ¬ª : {
"payload_raw": "aGVsbG8=" }
| 61

Figure 69 : Configuration du Publisher Vous devriez voir les donn√©es arriver sur votre Device LoRA.
| 62

7 Cr√©ation de notre propre Network et Application Server
7.1.1 Objectifs Lors de la mise en ≈ìuvre du r√©seau LoRaWAN au chapitre 5.2, nous avons utilis√© TTN (The Things Network) pour jouer le r√¥le de Network Server et d‚ÄôApplication Server. Pour de multiples raisons : S√©curit√©, autonomie, co√ªt‚Ä¶il peut √™tre int√©ressant de monter soi-m√™me un Network Server et un Application Server. Cela est possible seulement si vous poss√©dez vos propres Gateway puisque celles-ci devront forwarder leur paquet √† destination pr√©cise. Il faudra donc les reconfigurer pour qu‚Äôelles pointent vers votre nouvelle architecture.
7.1.2 Pr√©sentation de LoRaServer LoRaServer [ www.loraserver.io ] est un projet Open-Source r√©pondant exactement au besoin que nous avons. Nous l‚Äôutiliserons sur une cible Raspberry PI. En r√©alit√©, il peut souvent √™tre mise en place dans le m√™me syst√®me que la Gateway, surtout si celle-ci est elle-m√™me √† base de RPI. Les Gateway EBDS que nous poss√©dons poss√®dent d‚Äôailleurs un Network Server et un Application Server que nous aurions pu utiliser. N√©anmoins, pour des raisons p√©dagogiques, il est int√©ressant de s√©parer les syst√®mes pour bien diff√©rencier les probl√©matiques.

Raspberry PI IP

Devices : Arduino RN2483

Gateways : EBDS

Network Server

Application Server

Figure 70 :Architecture globale de notre r√©seau loRaWAN

Attention, il y a une ambigu√Øt√© dans la d√©nomination des entit√©s logiciels de LoRaServer. LoRaServer (sans espace entre le mot LoRa et Server) est le nom du projet global. En revanche, LoRa Server (avec un espace) est le nom du service qui joue le r√¥le du Network Server.
L‚Äôarchitecture et le fonctionnement de LoRaServer est pr√©sent√©e dans sa documentation par le sch√©ma suivant :

| 63

Figure 71 : Architecture d√©taill√©e de LoRaServer On s‚Äôattends √† voir uniquement un Network Server (LoRa Server) et un Application Server (LoRa App Server) mais ce sch√©ma est plus complexe. Il demande un certain nombre d‚Äôexplications pour bien comprendre ce que nous allons installer et la fa√ßon dont nous l‚Äôutiliserons par la suite.
7.1.3 Le ¬´ Packet Forwarder ¬ª (Gateway) Comme nous l‚Äôavons vu au chapitre 4.1.2, les Gateways LoRa sont des passerelles entre la modulation LoRa et un r√©seau IP. Pour r√©aliser cette passerelle, un service nomm√© ¬´ UDP Packet Forwarder ¬ª a √©t√© d√©velopp√© par Semtech : https://github.com/Lora-net/packet_forwarder . Dans ce dossier github, un fichier nomm√© PROTOCOL.TXT explique parfaitement ce protocole applicatif qui travaille au-dessus de UDP.
Figure 72 : Protocole Uplink (PUSH_DATA du Packet Forwarder)
| 64

On remarque que les paquets sont envoy√©s en UDP au Network Server dans une trame appel√©e PUSH_DATA . Cette trame est acquitt√©e par le Network Server par une trame appel√©e PUSH_ACK.
Sur notre Network Server, nous pouvons r√©aliser une capture de trame pour v√©rifier si le protocole est bien celui pr√©sent√© dans le document :

Figure 73 : Trame captur√©e par Wireshark lors d'un Uplink

D‚Äôapr√®s la capture pr√©c√©dente, on remarque que le Packet Forwarder fonctionne bien avec UDP sur le port 1700.
Le contenu des donn√©es (champ Data) est d√©taill√© dans le tableau suivant :

Champ | Num octet |

Fonction

-------|--------------------------------------------------------

[1] | 0

| protocol version = 0x02

[2] | 1-2

| random token

[3] | 3

| PUSH_DATA identifier = 0x00

[4] | 4-11 | Gateway unique identifier (MAC address)

[5] | 12-end | JSON object, starting with {, ending with }

Champ [1] Champ [2] Champ [3] Champ [4]

0000 0010 0020 0030 0040 0050 0060 0070 0080 0090 00a0 00b0 00c0

02 f9 30 00 b8 27 eb ff fe ae 26 f5 7b 22 72 78 70 6b 22 3a 5b 7b 22 74 6d 73 74 22 3a 33 37 35 35 30 30 35 38 31 39 2c 22 63 68 61 6e 22 3a 32 2c 22 72 66 63 68 22 3a 31 2c 22 66 72 65 71 22 3a 38 36 38 2e 35 30 30 30 30 30 2c 22 73 74 61 74 22 3a 31 2c 22 6d 6f 64 75 22 3a 22 4c 4f 52 41 22 2c 22 64 61 74 72 22 3a 22 53 46 37 42 57 31 32 35 22 2c 22 63 6f 64 72 22 3a 22 34 2f 35 22 2c 22 6c 73 6e 72 22 3a 36 2e 35 2c 22 72 73 73 69 22 3a 2d 31 2c 22 73 69 7a 65 22 3a 31 38 2c 22 64 61 74 61 22 3a 22 51 4e 4d 61 41 53 59 41 41 51 41 50 70 79 50 5a 39 35 35 2b 53 6d 59 2f 22 7d 5d 7d

..0..'....&.{"rx pk":[{"tmst":375 5005819,"chan":2 ,"rfch":1,"freq" :868.500000,"sta t":1,"modu":"LOR A","datr":"SF7BW 125","codr":"4/5 ","lsnr":6.5,"rs si":-1,"size":18 ,"data":"QNMaASY AAQAPpyPZ955+SmY /"}]}

Figure 74 : Analyse du champ Donn√©es du protocole ¬´ Packet Forwarder ¬ª L‚Äôobjet JSON de la transmission r√©√©crit plus proprement est celui-ci :

| 65

{ "rxpk":[{ "tmst":3755005819, "chan":2, "rfch":1, "freq":868.500000, "stat":1, "modu":"LORA", "datr":"SF7BW125", "codr":"4/5", "lsnr":6.5, "rssi":-1, "size":18, "data":"QNMaASYAAQAPpyPZ955+SmY/" }]
}
Le champ "data" correspond au PHY Payload.
De la m√™me fa√ßon on retrouve la Trame d‚Äôacquittement :

Figure 75 : Trame captur√©e par Wireshark lors de l‚Äôacquittement d‚Äôun Uplink

Champs | Num octet |

Fonction

-------|--------------------------------------------------------

[1] | 0

| protocol version = 0x02

[2] | 1-2

| same token as the PUSH_DATA to acknowledge

[3] | 3

| PUSH_ACK identifier = 0x01

Nous retrouvons bien tous ces champs dans la trame Wireshark.
7.1.4 LoRa Gateway Bridge Nous avons d√©crit au chapitre pr√©c√©dent (7.1.3) le fonctionnement du Packet Forwarder. Le Network Server(Lora Server) que nous allons mettre en place aurait tr√®s bien pu s‚Äôinterfacer directement √† ce protocole. Mais cela aurait plusieurs impacts dont un qui est important dans la conception de logiciel : Si le Packet Forwarder change, ou si un autre type de Forwarder est utilis√©, alors l‚Äôutilisation du LoRa Server devient impossible. Il a donc √©t√© choisi de cr√©er une √©tape interm√©diaire. Le Network Server que nous mettrons en plus utilisera le protocole MQTT plut√¥t que le protocole UDP packet Forwarder.
En d‚Äôautres termes, le LoRa Gateway Bridge est un service qui fera abstraction du Packet Forwarder pour s‚Äôinterfacer plus simplement avec le Network Server.

7.1.5 LoRa Server (Network Server) Il s‚Äôagit de notre Network Server qui a le m√™me r√¥le que celui que nous avons √©tudi√© au chapitre 4.1.3. Cependant, il s‚Äôinterfacera au protocole MQTT en recevant les informations √† partir du Broker au lieu de recevoir directement les trames en provenance de la Gateway.

| 66

7.1.6 LoRa App Server (Application Server) Il s‚Äôgit de notre Application Server qui a le m√™me r√¥le que celui que nous avons √©tudi√© au chapitre 4.1.4.
7.1.7 LoRa Geo Server Il s‚Äôagit d‚Äôun service qui permet d‚Äôutiliser certaines propri√©t√©s du protocole LoRa pour proposer un service de g√©olocalisation des Devices LoRa. Nous ne l‚Äôutiliserons pas dans notre cas.
7.1.8 Application Il s‚Äôagit de notre Application qui a le m√™me r√¥le que celui que nous avons √©tudi√© au chapitre 4.1.5. Elle ne fait pas partie du projet LoRaServer, c‚Äôest donc bien toujours √† nous de proposer notre propre Application.
Figure 76 : Les interfaces possibles entre LoRaServer et l‚ÄôApplication utilisateur Comme nous pouvons le voir sur la figure pr√©c√©dente, deux possibilit√©s sont offertes pour interfacer notre application : JSON REST (incluant HTTP POST) et via un Broker MQTT. Ces deux m√©thodes ont d√©j√† √©t√© trait√©e au chapitre 6.1 (HTTP POST ) et au chapitre 6.2 (MQTT). Nous verrons aussi d‚Äôautres possibilit√©s pour personnaliser notre application au chapitre 7.
7.2 Installation de LoRaServer
7.2.1 Mise en place de l‚Äôenvironnement Nous allons installer une carte SD avec la derni√®re version de Raspbian. Nous ne d√©taillerons pas la d√©marche pour cela car elles sont largement document√©es et mises √† jour sur le site www.raspberrypi.org .
Installer un carte SD avec la derni√®re version de Raspbian Plut√¥t que de fonctionner avec un clavier et une souris, nous pr√©conisons de travailler √† distance avec la RPI via une connexion SSH. Depuis quelques ann√©es Raspbian a supprim√© le d√©marrage du service SSH au boot. Heureusement il est possible de le r√©activer par la m√©thode suivante :
Avec Windows ou Linux, ouvrir la partition BOOT de votre carte SD et placer un fichier √† la racine nomm√© ssh.txt (ou ssh). Mettre la carte SD dans votre RPI et la d√©marrer
| 67

Pour acc√©der √† la RPI en SSH depuis Windows, nous utiliserons de pr√©f√©rence le logiciel client : MobaXterm, mais tout autre client SSH est valable.
Installer MobaXterm sur votre PC et connectez-vous √† votre Raspberry PI.
L‚Äôutilisation d‚Äôun espion de r√©seau type Wireshark peut √™tre int√©ressant pour √©tudier les trames qui sont re√ßues et qui sont √©mises. Cela nous permettra de valider le fonctionnement des diff√©rents protocoles r√©seau qui permettent de communiquer √† la Gateway d‚Äôune part, et √† l‚ÄôApplication d‚Äôautre part. Nous utiliserons tshark.
‚ñ† apt-get install tshark // installation ‚ñ† tshark ‚Äìn -i eth0 // Exemple d‚Äôune analyse sur l‚Äôinterface wlan0
7.2.2 Installation sur la Raspberry PI La m√©thode d‚Äôinstallation de LoRaServer est document√©e sur le site web √† l‚Äôadresse suivante: [ https://www.loraserver.io/guides/debian-ubuntu/ ] . Nous installerons le LoRa Gateway Bridge, le LoRa Server et le LoRa App Server.

Internet

Devices

Gateways LoRa UDP Packet Forwarder

Network Server Application Server

LoRa Gateway Bridge LoRa Server

LoRa App Server

Figure 77 : Architecture globale apr√®s installation de LoRaServer
Apr√®s l‚Äôinstallation, la configuration se fait par une interface graphique accessible par le r√©seau sur le port 8080.
‚ñ† Si vous travaillez sur la RPI, connectez-vous sur : http://localhost:8080/ ‚ñ† Si vous travaillez √† distance (SSH), connectez-vous sur : http://@IP_RPI:8080
Les Usernames et Password par d√©faut sont : ‚ñ† Username: admin ‚ñ† Password: admin
L‚Äô√©cran d‚Äôaccueil sera donc le suivant :

| 68

Figure 78 : Ecran d'accueil de LoRaServer apr√®s authentification
7.1 Configuration de LoRa Server pour l'Uplink
7.1.1 Enregistrement d‚Äôune nouvelle Organisation Pour enregistrer une nouvelle Organizations : Organizations > Create. Puis entrer les configurations suivantes :
Figure 79 : Enregistrement d'un nouvelle Organisation 7.1.2 Enregistrement d‚Äôune instance du Network Server Pour enregistrer une nouvelle instance du Network Server : Network Server > Create. Puis entrer les configurations suivantes :
| 69

Figure 80 : Enregistrement d'un nouveau Network Server
Dans l‚Äôonglet Gateway Discovery, il est possible d‚Äôactiver une option de d√©couverte de Gateway aux alentours. Lorsqu‚Äôelle est configur√©e, le Network Server va envoyer une trame Downlink de configuration de la Gateway lui ordonnant de r√©aliser des PING en LoRa. La configuration du Gateway Discovery pr√©voit de sp√©cifier :
‚ñ† Le nombre de fois par jour que les PING LoRa sont envoy√©s ‚ñ† Le canal d‚Äô√©mission ‚ñ† Le Data Rate (Voir paragraphe 4.4.5)
Un PING LoRa re√ßu sur une Gateway sera retransmis sur le Network Server (Lora Server) et une carte sera affich√©e.
L‚Äôonglet TLS Certificates ne sera pas utilis√© dans le cadre de notre d√©monstration.

7.1.3 Enregistrement d‚Äôune Application (Sur l‚ÄôApplication Server) Il faut tout d‚Äôabord faire un enregistrement d‚Äôun ¬´ service-profile ¬ª. Un ¬´ service profile permet de faire la connexion entre le Network Server et les Applications que nous enregistrerons dans notre Organisation : Service-profiles > Create.

‚ñ† Service-profile name : myServiceProfile

‚ñ† Network-server :

myNetworkServer

On laissera par d√©faut toutes les autres options.
Pour enregistrer une nouvelle Application : Applications > Create. Puis entrer les configurations suivantes

| 70

Figure 81 : Enregistrement d'une nouvelle Application 7.1.4 Enregistrement des Devices LoRa Il faut tout d‚Äôabord faire l‚Äôenregistrement d‚Äôun Device-profile pour les Devices LoRa que vous souhaitez connecter. Dans notre cas, nous ferons un premier test en sp√©cifiant que nous utilisons seulement le mode d‚Äôauthentification ABP (voir chapitre 4.3.1).: Devices profile > Create
Figure 82 : Enregistrement d'un ¬´ Device profile ¬ª Nous pouvons alors cr√©er dans notre Application des nouveaux Devices : Application > myApplication > Create
| 71

Figure 83 : Enregistrement d'un nouveau Device LoRa Dans la fen√™tre Activation, on va alors configurer les 3 √©l√©ments indispensables √† une authentification en APB : Le DevAddr, le NwkSKey, et l‚ÄôAppSKey.
Figure 84 : Configuration de l'enregistrement du Device LoRa (en ABP) La configuration minimale de LoRaServer est maintenant termin√©e. Nous pouvons donc brancher un Device LoRa qui poss√®de les les attribus (DevAddr, NwkSKey et AppSKey) que nous avons enregistr√© dans LoRaServer et le faire √©mettre.
7.1.5 Visualisation des trames re√ßues Les trames √©mises par le Device LoRa vont donc parcourir le cheminement suivant :
| 72

Gateway

Server

UDP

Internet

Packet Forwarder

LoRa Bridge Gateway

LoRa Server

LoRa App Server

Figure 85 : R√©sum√© du cheminement des trames LoRaWan en Uplink avec LoRaServer
En allant dans le Live Device Data (Application > Nom_du_Device > Live Device Data) on peut voir la liste des trames re√ßues ainsi que les donn√©es applicatives d√©chiffr√©es.

Figure 86 : R√©ception des trames des Devices LoRa
Figure 87 : Analyse des trames des Devices LoRa Dans l‚Äôonglet LIVE LORAWAN FRAME, nous pouvons voir les trames LORAWAN, et si besoin √©tudier le contenu de ce qu‚Äôelles contiennent. En revanche, les donn√©es applicatives sont ici chiffr√©es.
| 73

Figure 88 : R√©ception des Trames LoRaWAN
7.2 Configuration de LoRaServer pour l'int√©gration d'Application
Nous avons vu dans le chapitre 7.1.8 que l'interface entre LoRaServer et notre Application pouvait √™tre r√©alis√©e soit par MQTT, soit par les m√©thodes REST (HTTP POST). Nous avons d√©j√† impl√©ment√© et expliqu√© ces protocoles dans le cadre de son utilisation avec TTN. Nous allons donc juste configurer LoRaServer pour tester ces deux m√©thodes.
7.2.1 R√©cup√©rer des donn√©es sur notre Application avec HTTP POST Nous utiliserons exactement la m√™me m√©thode que celle que nous avons utilis√© avec TTN au chapitre 6.1.5. Les diff√©rentes Clients et Serveurs disponibles pour ces tests sont expliqu√©s au paragraphe 6.1.2. Dans LoRaServer, ajouter une int√©gration HTTP : LoRaServer > Applications > myApplication > Integrations > Create > HTTP Integration et la configurer comme le montre la Figure 89. Vous remplacerez √©videment le lien par votre propre Endpoints.
Figure 89 : Configuration de l'int√©gration HTTP POST dans LoRaServer En envoyant des trames LoRa depuis votre Device, vous devriez voir les contenus JSON sur votre Endpoint.
7.2.2 R√©cup√©rer des donn√©es sur notre Application avec MQTT Nous allons nous connecter au Broker MQTT de LoRaServer. Pour cela nous utiliserons la m√™me m√©thode que celle que nous avons utilis√© avec TTN au chapitre 6.2.8 . Nous utiliserons MQTTBox, comme nous l'avons d√©j√† fait au paragraphe 6.2.7. Le Broker de LoRaServer a enregistr√© les Topics suivant :
‚ñ† [applicationID] correspond au nom de votre Application ‚ñ† [devEUI] correspond au nom de votre Device LoRa
| 74

D√©tail du Topic

Nom du Topic

[Donn√©es] Flux Uplink

application/[applicationID]/device/[devEUI]/rx

[Donn√©es] Flux Downlink

application/[applicationID]/device/[devEUI]/tx

[Status] Statut d'un Device

application/[applicationID]/device/[devEUI]/status

[Ack] Acquittement des messages

application/[applicationID]/device/[devEUI]/ack

[Erreurs] Erreurs

application/[applicationID]/device/[devEUI]/error

Tableau 13 : Topics enregistr√©s dans LoRaServer

| 75

8 Cr√©ation de notre propre Application
8.1 Utilisation de Node-RED
8.1.1 Pr√©sentation Node-RED est un outil de programmation graphique qui permet de faire communiquer les p√©riph√©riques mat√©riels d‚Äôun syst√®me sans √©crire de code. De nombreux protocoles sont aussi pris en charge au travers de bloc ( Node) qu‚Äôil suffit de connecter entre eux pour r√©aliser simplement une application. Il peut s‚Äôex√©cuter localement sur un PC ou sur des cibles embarqu√©es telle qu‚Äôune Raspberry PI (RPI). Dans les d√©monstrations que nous mettrons en ≈ìuvre, nous utiliserons une RPI. Par soucis de simplicit√©, nous utiliserons les derni√®res versions de Raspbian (syst√®me d‚Äôexploitation de la RPI) qui int√®gre d‚Äôorigine Node-RED. Il n‚Äôy a donc tr√®s peu de chose √† mettre en place pour arriver √† mettre en place une Application. Nous pouvons travailler soit directement sur la RPI √† l‚Äôaide d‚Äôune sourisclavier, mais il est recommand√© de travailler √† distance avec une connexion SSH.
8.1.2 Mise en place de l‚Äôenvironnement La mise en place de la RPI avec le syst√®me d‚Äôexploitation Raspbian a √©t√© pr√©sent√© au chapitre 7.2.1. Vous pouvez reprendre la m√™me installation ou repartir sur une nouvelle. Il est possible de faire en sorte que Node-RED se lance directement au d√©marrage gr√¢ce √† la commande : sudo systemctl enable nodered.service S'il n'est pas actif, lancer Node-RED sur votre RPI : node-red-start Nous nous connectons au Node-RED de la RPI via un navigateur web sur le port 1880 en tapant dans la barre d'URL : http://@IP_Raspeberry_PI:1880/ . Ce nous permet d'arriver √† la fen√™tre suivante :
Figure 90 : Page d'accueil de Node-RED Il est possible de s'interfacer avec TTN avec les Nodes d√©j√† disponibles : gr√¢ce au protocole HTTP POST ou MQTT. N√©anmoins, nous pouvons avantageusement installer deux librairies sp√©cifiques :
‚ñ† Une qui facilite l'interfa√ßage avec TTN ‚ñ† Une qui facilite la mise en place d'interface graphique Installation des Nodes TTN :
cd $HOME/.node-red npm install node-red-contrib-ttn Installation de Dashboard (interface graphique)
| 76

cd $HOME/.node-red npm install node-red-dashboard
Il peut √™tre necessaire de red√©marrer Node-RED pour prendre en compte l'installation de nos deux Nodes.
----------------------------------sudo apt-get install npm sudo npm install -g npm hash -r cd ~/.node-red npm install node-red-{example node name} ------------------------------------
8.1.3 Cr√©er une Application sp√©cifique pour TTN Nous allons commencer par g√©rer le flux Uplink. Apporter sur votre sch√©ma un Node ''ttn uplink" et un Node "Debug" puis relier les. Le Node "ttn uplink" nous permettra de configurer la communication avec TTN en MQTT. Le Node "debug" √©crira sur le terminal les informations brutes qui seront re√ßu par le Node "ttn uplink".
Figure 91 : Visualisation des trame publi√©es par TTN sur notre client MQTT
Double cliquer sur le Node ttn uplink pour le configurer comme la figure suivante : Le champ "Name" sera le nom du Node sur votre sch√©ma. Le champ Device ID est le device LoRa concern√© dans votre application. De plus, il faut entrer les caract√©ristiques de votre application (Add new ttn app) pour que Node-RED puisse s'y connecter.

Figure 92 : Configuration du node "ttn uplink" Configuration de votre nouvelle application :

| 77

Figure 93 : Identifiant et mot de passe de notre application ‚ñ† AppID : Nom de votre application. Dans notre cas "seminaire_lorawan". ‚ñ† Access Key : Comme nous l'avons d√©j√† expliqu√© plus t√¥t, l' "Access Key" vous sera donn√©e
par l‚Äôenseignant dans le cadre de ce test. Si vous avez enregistr√© votre propre application, vous trouverez l‚ÄôAccess Key dans : TTN > Application > Nom_de_votre_application > Overview. Le Node "ttn uplink" doit maintenant avoir le nom que vous avez configur√©. Cliquer sur Deploy pour lancer votre projet. Le bloc "ttn uplink" doit maintenant √™tre connect√© √† TTN. Cela est sp√©cifi√© "connected" sous le bloc.
Figure 94 : Utilisation du Node TTN Uplink R√©aliser un test de communication gr√¢ce √† une simulation d'uplink comme nous l'avons vu au paragraphe 5.4.5 : TTN > Application > Nom_de_votre_application > Devices > arduino0
Figure 95 : Simulation de Uplink dans TTN Vous devriez voir le r√©sultat dans la fen√™tre de Debug. Par exemple pour le test d'envoi de 31 32, correspondant au code ASCII des chiffres '1' et '2', vous devriez avoir la fen√™tre de Debug suivante :
| 78

Figure 96 : R√©sultats obtenu dans la fen√™tre Debug apr√®s la simulation d'Uplink 8.1.4 Cr√©ation d‚Äôun Dashboard Dans la mise en place de l'environnement (chapitre 8.1.2), nous avons install√© des Nodes "Dashboard" qui vont nous permettre de r√©aliser une interface graphique tr√®s simple et de la mettre √† disposition des utilisateurs via un des graphiques, histogramme, gauges, afficheurs‚Ä¶
Figure 97 : Impl√©mentation d'une interface graphique dans Node RED L'interface graphique que nous allons cr√©er sera constitu√©e d'onglet (tab). La mise en place des composant se fait de la fa√ßon suivante :
‚ñ† Chaque √©l√©ment graphique doit appartenir √† un groupe de composant qu'il va falloir cr√©er. ‚ñ† Chaque groupe de composant doit appartenir √† un onglet (tab) qu'il va falloir cr√©er.
Figure 98 : Cr√©ation d'un groupe de composant
Figure 99 : Cr√©ation d'un nouvel onglet dans le site web Cliquer sur Deploy pour activer votre application LURL pour joindre l'interface graphique de votre site web est disponible sur l'adresse http://@IP_Raspeberry_PI:1880/ui . R√©aliser un test de communication gr√¢ce √† une simulation d'uplink comme nous l'avons vu au paragraphe 5.4.5 : TTN > Application > Nom_de_votre_application > Devices > arduino0
| 79

Figure 100 : Interface graphique du site web avec Node-RED

8.2 Programmation en PHP
Maintenant que nous avons test√© toute l‚Äôarchitecture, nous pouvons mettre en place une application qui jouera deux r√¥les :
‚ñ† Un r√¥le de Serveur HTTP POST r√©cup√©rant les donn√©es en provenance de TTN ‚ñ† Un r√¥le de Client HTTP POST qui g√©n√©rera les requ√™tes vers TTN
Un serveur web apache sur RPI h√©berge cette application. L'interface graphique du site web est r√©alis√© avec le template CSS propos√© par Bootstrap [ https://getbootstrap.com/ ]
The Things Network

Requ√™te (1 ) HTTP POST
[ Flux Uplink ]

Requ√™te (2) HTTP POST
[ Flux Downlink ]

Notre Application [ Serveur Apache sur Raspberry Pi ]
Figure 101 : Architecture de notre application en PHP sur RPI

| 80

Nous allons l‚Äôutiliser telle quelle. Elle est juste propos√©e √† titre d'exemple L‚Äôobjectif de cette application est de g√©n√©rer une ouverture / fermeture de ruche √† distance dans le cadre de projets √©tudiants du Master Electronique et Syst√®mes Embarqu√©s de l'USMB : [ http://scem-eset.univsmb.fr/ ]
Figure 102 : Application permettant de recevoir et d'√©mettre des requ√™tes HTTP POST Configurer TTN pour pointer vers votre nouveau serveur, et tester le flux montant et descendant.
| 81

9 Versions du document

Version 1.0 :

02/02/2019

‚ñ† Version initiale.

Version 2.0 :

23/02/2019

‚ñ† Ajout d‚Äôun paragraphe : Les syst√®mes embarqu√©s dans l‚ÄôIoT / En introduction ‚ñ† Compl√©ment et am√©lioration : Am√©lioration exercice √©talement de spectre ‚ñ† Correction : C√¢blage Arduino ‚ñ† Ajout d‚Äôun paragraphe : Fonctionnement de l‚ÄôArduino et ajout de librairies. ‚ñ† Compl√©ment et am√©lioration : Couche physique LoRa. Ajout de 4 figures pour l‚Äôexplication
de la modulation Chirp. ‚ñ† Ajout d‚Äôun paragraphe sur les acronymes utilis√©s au d√©but du cours : TTN, LoRa, MQTT‚Ä¶ ‚ñ† Compl√©ment d‚Äôinformations sur les dB et dBm ‚ñ† Ajout LoRa Calculator

Version 3.0 :

8/03/2019

‚ñ† Ajout de figure sur le r√¥le de la Gateway LoRa ‚ñ† Ajout de paragraphe authentification avec le Network Server ‚ñ† Ajout de paragraphe sur le chiffrement avec l‚ÄôApplication Server ‚ñ† Ajout d‚Äôun sommaire en d√©but de cours ‚ñ† Ajout de 2 sch√©mas : ABP et OTAA ‚ñ† Retrait explication du d√©tail de la ¬´ Join Request ¬ª en OTAA : Trop complexe, attente de
r√©alisation d‚Äôun sch√©ma plus explicite. ‚ñ† Ajout d‚Äôun sch√©ma sur l‚Äôattaque par REPLAY ‚ñ† Ajout de paragraphe des diff√©rents r√©seaux LoRaWAN existants : Op√©r√©s et Priv√©s ‚ñ† Ajout des sch√©mas des trames LoRaWAN : Physique / LoRa MAC / Application ‚ñ† Compl√©ment d‚Äôinformation sur les Classes de Devices ‚ñ† Ajout d‚Äôun paragraphe sur la Gateway utilis√©e pour le Downlink ‚ñ† Ajout d‚Äôun paragraphe sur le JSON ‚ñ† Compl√©ment d‚Äôinformation sur le codage en Base64 ‚ñ† Ajout d‚Äôinformation dans le d√©codage des trames LoRaWAN ‚ñ† Restructuration des explications sur l‚Äôenvoi et la r√©cup√©ration des donn√©es en HTTP/MQTT

Version 4.0 :

8/03/2019

‚ñ† Ajout d‚Äôun chapitre : Cr√©ation de notre propre Application ‚ñ† Ajout d‚Äôun chapitre : Cr√©ation de notre propre Network et Application Server ‚ñ† Ajout d‚Äôune figure : Visualisation des Chirps LoRa par SDR (Radio Logicielle) ‚ñ† Compl√©ments d‚Äôinformation sur MQTT ‚ñ† Compl√©ments d'information sur les Topics de TTN en MQTT

| 82

